<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <link href="/katexify/katex.min.css" rel="stylesheet" />
    <meta name="description" content="01 | 崩溃优化（上）：关于“崩溃”那些事儿Android 的两种崩溃 Java 崩溃: 在 Java 代码中，出现了未捕获异常，导致程序异常退出。 Native 崩溃: 一般是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，这些都会产生相应的 signal 信号，导致程序异常退出。">
<meta property="og:type" content="article">
<meta property="og:title" content="极客时间 - 《Android开发高手课》笔记">
<meta property="og:url" content="http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="月半兄的小站">
<meta property="og:description" content="01 | 崩溃优化（上）：关于“崩溃”那些事儿Android 的两种崩溃 Java 崩溃: 在 Java 代码中，出现了未捕获异常，导致程序异常退出。 Native 崩溃: 一般是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，这些都会产生相应的 signal 信号，导致程序异常退出。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/95/11/95d9733860e3a52c6c3b5976ca25b711.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/c2/ce/c26a9351868bb82abd7ada028275f5ce.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/07/97/0739a98bfafdd9f59539ddbbf403f097.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/b8/98/b8d160f8d487bcb377e0c38ff9a0ac98.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/52/0b/526d72f3dbc70ef45c00e7c0e7bdd80b.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/12/15/127526ef09381587f48fb16187b91715.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/de/5f/de8b2064c4fee25166602781fbff915f.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/db/3e/db3612f661d29efe59854df2e6c2383e.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/6c/01/6ca232173daf9e71f06ac22252d65d01.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/10/b3/10a39c4253447b3e9d0a5045795d47b3.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/b0/56/b06d5aa439e8bb75885a338df9a25f56.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/8e/bf/8ee841e21f4a40f2835fe846be143dbf.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/55/aa/5554d062dd45d6d927a08be4a39926aa.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/7f/fc/7f4abeb31fbc50546b0481435e7a7bfc.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/2f/b7/2f00261346ba4c85c9ae522766cf05b7.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/73/ba/73b185f989a20e868886d10c864c43ba.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/d4/67/d4e8abcb054793168dff716c7956ae67.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/53/0c/534e422d44eb4b08ebdac2181b87f70c.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/23/46/2398281c40faaa3620f48e1d23da9046.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/af/4b/af6485856d47626b13433f96ec48d44b.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/ca/5d/ca54f510455317ce487476cbe9cd285d.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/0d/43/0da2051f1f8d182a531063eb202abf43.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/36/b2/36316813548502f6cf241189e2a73cb2.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/86/db/868a5f4c47224be920e97b82d03905db.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/b9/d7/b901216f4231f43475ca1227f25b6ed7.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/5f/04/5f118a4064ada2fc6b978f4025d57404.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/ea/b1/eaef116a5c0d6be1f3687b159fd214b1.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/d2/d2/d2dbf21396e16c0cd53bbc3c0be405d2.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/ac/fd/acbbb4f9b147d68bfe9ab519642616fd.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/60/d4/60928bc51c0d04b1c39b24282e8126d4.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/fb/4b/fb11cbe604eb6c0fc2ba5825275f104b.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/13/18/13c06810c88632db1050ab3e56139a18.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/f3/b1/f3bcc6974bf879f35a842ecd8ee086b1.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/5f/a2/5fcc14c666f9c5c6d0cfb803634b2ba2.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/3e/38/3e295519291c337bb394fb5fdbd7d538.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/43/bd/431742f4ad3aefcc90334c905a729abd.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/d7/e0/d7a24f0fe50d56df0b4f315b12d065e0.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/11/3e/116ada829f5017f3d40bf2f78d4f4c3e.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/3f/43/3f322506a458d60145cee27f55673743.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/22/f9/22141f888cefc43219b0c3df3ab8d4f9.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/ba/3c/ba36f8e259427bde06bc44861905c63c.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/07/ae/0732644e3734490825c896fa559bcaae.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/aa/fb/aab6899b0b7a91f466e187333337dcfb.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/f0/5f/f0394337bee26e8bf105cfd1eda37a5f.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/9c/3a/9c408d0ec409771c2a036f0208cadf3a.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/81/f5/81fa5cac7b7c91e0687c11fb83e35df5.png">
<meta property="article:published_time" content="2019-04-09T09:26:46.000Z">
<meta property="article:modified_time" content="2020-11-08T10:35:32.488Z">
<meta property="article:author" content="月半兄">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/95/11/95d9733860e3a52c6c3b5976ca25b711.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-192x192.png">
        
      
    
    <!-- title -->
    <title>极客时间 - 《Android开发高手课》笔记</title><meta name="robots" content="noindex">
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/about/">关于</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&text=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&title=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&is_video=false&description=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=极客时间 - 《Android开发高手课》笔记&body=Check out this article: http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&title=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&title=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&title=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&title=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&name=极客时间 - 《Android开发高手课》笔记&description=&lt;h1 id=&#34;01-崩溃优化（上）：关于“崩溃”那些事儿&#34;&gt;&lt;a href=&#34;#01-崩溃优化（上）：关于“崩溃”那些事儿&#34; class=&#34;headerlink&#34; title=&#34;01 | 崩溃优化（上）：关于“崩溃”那些事儿&#34;&gt;&lt;/a&gt;01 | 崩溃优化（上）：关于“崩溃”那些事儿&lt;/h1&gt;&lt;h3 id=&#34;Android-的两种崩溃&#34;&gt;&lt;a href=&#34;#Android-的两种崩溃&#34; class=&#34;headerlink&#34; title=&#34;Android 的两种崩溃&#34;&gt;&lt;/a&gt;Android 的两种崩溃&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java 崩溃:&lt;/strong&gt; 在 Java 代码中，出现了未捕获异常，导致程序异常退出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Native 崩溃:&lt;/strong&gt; 一般是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，这些都会产生相应的 signal 信号，导致程序异常退出。&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&t=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#01-崩溃优化（上）：关于“崩溃”那些事儿"><span class="toc-number">1.</span> <span class="toc-text">01 | 崩溃优化（上）：关于“崩溃”那些事儿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-的两种崩溃"><span class="toc-number">1.0.1.</span> <span class="toc-text">Android 的两种崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Native-崩溃"><span class="toc-number">1.0.2.</span> <span class="toc-text">Native 崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何客观地衡量崩溃"><span class="toc-number">1.0.3.</span> <span class="toc-text">如何客观地衡量崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何客观地衡量稳定性"><span class="toc-number">1.0.4.</span> <span class="toc-text">如何客观地衡量稳定性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02-崩溃优化（下）：应用崩溃了，你应该如何去分析？"><span class="toc-number">2.</span> <span class="toc-text">02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#崩溃现场"><span class="toc-number">2.0.1.</span> <span class="toc-text">崩溃现场</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#崩溃分析"><span class="toc-number">2.0.2.</span> <span class="toc-text">崩溃分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03-内存优化（上）：4GB内存时代，再谈内存优化"><span class="toc-number">3.</span> <span class="toc-text">03 | 内存优化（上）：4GB内存时代，再谈内存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存问题"><span class="toc-number">3.0.1.</span> <span class="toc-text">内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#两个问题"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">两个问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个误区"><span class="toc-number">3.0.1.2.</span> <span class="toc-text">两个误区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-Bitmap-内存分配的变化"><span class="toc-number">3.0.1.3.</span> <span class="toc-text">Android Bitmap 内存分配的变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何将图片放到-Native-内存"><span class="toc-number">3.0.1.4.</span> <span class="toc-text">如何将图片放到 Native 内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测量方法"><span class="toc-number">3.0.2.</span> <span class="toc-text">测量方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-内存优化（下）：内存优化这件事，应该从哪里着手？"><span class="toc-number">4.</span> <span class="toc-text">04 | 内存优化（下）：内存优化这件事，应该从哪里着手？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存优化探讨"><span class="toc-number">4.0.1.</span> <span class="toc-text">内存优化探讨</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存监控"><span class="toc-number">4.0.2.</span> <span class="toc-text">内存监控</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05-卡顿优化（上）：你要掌握的卡顿分析方法"><span class="toc-number">5.</span> <span class="toc-text">05 | 卡顿优化（上）：你要掌握的卡顿分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础知识"><span class="toc-number">5.0.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-时间"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">CPU 时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-性能"><span class="toc-number">5.0.1.2.</span> <span class="toc-text">CPU 性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卡顿问题分析指标"><span class="toc-number">5.0.1.3.</span> <span class="toc-text">卡顿问题分析指标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-卡顿排查工具"><span class="toc-number">5.0.2.</span> <span class="toc-text">Android 卡顿排查工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Traceview"><span class="toc-number">5.0.2.1.</span> <span class="toc-text">Traceview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nanoscope"><span class="toc-number">5.0.2.2.</span> <span class="toc-text">Nanoscope</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#systrace"><span class="toc-number">5.0.2.3.</span> <span class="toc-text">systrace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Simpleperf"><span class="toc-number">5.0.2.4.</span> <span class="toc-text">Simpleperf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工具选择"><span class="toc-number">5.0.2.5.</span> <span class="toc-text">工具选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可视化方法"><span class="toc-number">5.0.3.</span> <span class="toc-text">可视化方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06-卡顿优化（下）：如何监控应用卡顿？"><span class="toc-number">6.</span> <span class="toc-text">06 | 卡顿优化（下）：如何监控应用卡顿？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#卡顿监控"><span class="toc-number">6.0.1.</span> <span class="toc-text">卡顿监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#消息队列"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插桩"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">插桩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Profilo"><span class="toc-number">6.0.1.3.</span> <span class="toc-text">Profilo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他监控"><span class="toc-number">6.0.2.</span> <span class="toc-text">其他监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#帧率"><span class="toc-number">6.0.2.1.</span> <span class="toc-text">帧率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生命周期监控"><span class="toc-number">6.0.2.2.</span> <span class="toc-text">生命周期监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程监控"><span class="toc-number">6.0.2.3.</span> <span class="toc-text">线程监控</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">6.0.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06补充篇-卡顿优化：卡顿现场与卡顿分析"><span class="toc-number">7.</span> <span class="toc-text">06补充篇 | 卡顿优化：卡顿现场与卡顿分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#卡顿现场"><span class="toc-number">7.0.1.</span> <span class="toc-text">卡顿现场</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-实现"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">Java 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SIGQUIT-信号实现-获取-ANR-日志"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">SIGQUIT 信号实现 (获取 ANR 日志)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook-实现"><span class="toc-number">7.0.1.3.</span> <span class="toc-text">Hook 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他卡顿现场信息"><span class="toc-number">7.0.1.4.</span> <span class="toc-text">其他卡顿现场信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#卡顿分析"><span class="toc-number">7.0.2.</span> <span class="toc-text">卡顿分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#卡顿率"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">卡顿率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卡顿树"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">卡顿树</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07-启动优化（上）：从启动过程看启动速度优化"><span class="toc-number">8.</span> <span class="toc-text">07 | 启动优化（上）：从启动过程看启动速度优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动分析"><span class="toc-number">8.0.1.</span> <span class="toc-text">启动分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#启动过程分析"><span class="toc-number">8.0.1.1.</span> <span class="toc-text">启动过程分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启动问题分析"><span class="toc-number">8.0.1.2.</span> <span class="toc-text">启动问题分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动优化"><span class="toc-number">8.0.2.</span> <span class="toc-text">启动优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优化工具"><span class="toc-number">8.0.2.1.</span> <span class="toc-text">优化工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化方式"><span class="toc-number">8.0.2.2.</span> <span class="toc-text">优化方式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08-启动优化（下）：优化启动速度的进阶方法"><span class="toc-number">9.</span> <span class="toc-text">08 | 启动优化（下）：优化启动速度的进阶方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动进阶方法"><span class="toc-number">9.0.1.</span> <span class="toc-text">启动进阶方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-优化"><span class="toc-number">9.0.1.1.</span> <span class="toc-text">I&#x2F;O 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据重排"><span class="toc-number">9.0.1.2.</span> <span class="toc-text">数据重排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类的加载"><span class="toc-number">9.0.1.3.</span> <span class="toc-text">类的加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#黑科技"><span class="toc-number">9.0.1.4.</span> <span class="toc-text">黑科技</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动监控"><span class="toc-number">9.0.2.</span> <span class="toc-text">启动监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实验室监控"><span class="toc-number">9.0.2.1.</span> <span class="toc-text">实验室监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线上监控"><span class="toc-number">9.0.2.2.</span> <span class="toc-text">线上监控</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09-I-O优化（上）：开发工程师必备的I-O优化知识"><span class="toc-number">10.</span> <span class="toc-text">09 | I&#x2F;O优化（上）：开发工程师必备的I&#x2F;O优化知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-的基本知识"><span class="toc-number">10.0.1.</span> <span class="toc-text">I&#x2F;O 的基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件系统"><span class="toc-number">10.0.1.1.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#磁盘"><span class="toc-number">10.0.1.2.</span> <span class="toc-text">磁盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-I-O"><span class="toc-number">10.0.2.</span> <span class="toc-text">Android I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-闪存"><span class="toc-number">10.0.2.1.</span> <span class="toc-text">Android 闪存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个疑问"><span class="toc-number">10.0.2.2.</span> <span class="toc-text">两个疑问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-的性能评估"><span class="toc-number">10.0.3.</span> <span class="toc-text">I&#x2F;O 的性能评估</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-性能指标"><span class="toc-number">10.0.3.1.</span> <span class="toc-text">I&#x2F;O 性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-测量"><span class="toc-number">10.0.3.2.</span> <span class="toc-text">I&#x2F;O 测量</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-I-O优化（中）：不同I-O方式的使用场景是什么？"><span class="toc-number">11.</span> <span class="toc-text">10 | I&#x2F;O优化（中）：不同I&#x2F;O方式的使用场景是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-的三种方式"><span class="toc-number">11.0.1.</span> <span class="toc-text">I&#x2F;O 的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#标准-I-O"><span class="toc-number">11.0.1.1.</span> <span class="toc-text">标准 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#直接-I-O"><span class="toc-number">11.0.1.2.</span> <span class="toc-text">直接 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap"><span class="toc-number">11.0.1.3.</span> <span class="toc-text">mmap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程阻塞-I-O-和-NIO"><span class="toc-number">11.0.2.</span> <span class="toc-text">多线程阻塞 I&#x2F;O 和 NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程阻塞-I-O"><span class="toc-number">11.0.2.1.</span> <span class="toc-text">多线程阻塞 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO"><span class="toc-number">11.0.2.2.</span> <span class="toc-text">NIO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小文件系统"><span class="toc-number">11.0.3.</span> <span class="toc-text">小文件系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-I-O优化（下）：如何监控线上I-O操作？"><span class="toc-number">12.</span> <span class="toc-text">11 | I&#x2F;O优化（下）：如何监控线上I&#x2F;O操作？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-跟踪"><span class="toc-number">12.0.1.</span> <span class="toc-text">I&#x2F;O 跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-Hook"><span class="toc-number">12.0.1.1.</span> <span class="toc-text">Java Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Native-Hook"><span class="toc-number">12.0.1.2.</span> <span class="toc-text">Native Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#监控内容"><span class="toc-number">12.0.1.3.</span> <span class="toc-text">监控内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线上监控-1"><span class="toc-number">12.0.2.</span> <span class="toc-text">线上监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主线程-I-O"><span class="toc-number">12.0.2.1.</span> <span class="toc-text">主线程 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读写-Buffer-过小"><span class="toc-number">12.0.2.2.</span> <span class="toc-text">读写 Buffer 过小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重复读"><span class="toc-number">12.0.2.3.</span> <span class="toc-text">重复读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#资源泄漏"><span class="toc-number">12.0.2.4.</span> <span class="toc-text">资源泄漏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-与启动优化"><span class="toc-number">12.0.3.</span> <span class="toc-text">I&#x2F;O 与启动优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-存储优化（上）：常见的数据存储方法有哪些？"><span class="toc-number">13.</span> <span class="toc-text">12 | 存储优化（上）：常见的数据存储方法有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-的存储基础"><span class="toc-number">13.0.1.</span> <span class="toc-text">Android 的存储基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-分区"><span class="toc-number">13.0.1.1.</span> <span class="toc-text">Android 分区</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        极客时间 - 《Android开发高手课》笔记
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">月半兄</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-04-09T09:26:46.000Z" itemprop="datePublished">2019-04-09</time>
        
        (Updated: <time datetime="2020-11-08T10:35:32.488Z" itemprop="dateModified">2020-11-08</time>)
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Android/" rel="tag">Android</a>, <a class="tag-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="01-崩溃优化（上）：关于“崩溃”那些事儿"><a href="#01-崩溃优化（上）：关于“崩溃”那些事儿" class="headerlink" title="01 | 崩溃优化（上）：关于“崩溃”那些事儿"></a>01 | 崩溃优化（上）：关于“崩溃”那些事儿</h1><h3 id="Android-的两种崩溃"><a href="#Android-的两种崩溃" class="headerlink" title="Android 的两种崩溃"></a>Android 的两种崩溃</h3><ul>
<li><strong>Java 崩溃:</strong> 在 Java 代码中，出现了未捕获异常，导致程序异常退出。</li>
<li><strong>Native 崩溃:</strong> 一般是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，这些都会产生相应的 signal 信号，导致程序异常退出。</li>
</ul>
<a id="more"></a>

<h3 id="Native-崩溃"><a href="#Native-崩溃" class="headerlink" title="Native 崩溃"></a>Native 崩溃</h3><ul>
<li>Native 崩溃的捕获流程<br>  <img src="https://static001.geekbang.org/resource/image/95/11/95d9733860e3a52c6c3b5976ca25b711.jpg" alt=""><ul>
<li>编译端。编译 C/C++ 代码时，需要将带符号信息的文件保留下来。</li>
<li>客户端。捕获到崩溃时候，将收集到尽可能多的有用信息写入日志文件，然后选择合适的时机上传到服务器。</li>
<li>服务端。读取客户端上报的日志文件，寻找适合的符号文件，生成可读的 C/C++ 调用栈。</li>
</ul>
</li>
<li>Native 崩溃捕获的难点: 在上面的三个流程中，最核心的是怎么样保证客户端在各种极端情况下依然可以生成崩溃日志。在崩溃时，程序会处于一个不安全的状态，如果处理不当，非常容易发生二次崩溃。  <ul>
<li>情况一：文件句柄泄漏，导致创建日志文件失败，怎么办？<ul>
<li>应对方式：我们需要提前申请文件句柄 fd 预留，防止出现这种情况。</li>
</ul>
</li>
<li>情况二：因为栈溢出了，导致日志生成失败，怎么办？<ul>
<li>应对方式：为了防止栈溢出导致进程没有空间创建调用栈执行处理函数，我们通常会使用常见的 signalstack。在一些特殊情况，我们可能还需要直接替换当前栈，所以这里也需要在堆中预留部分空间。</li>
</ul>
</li>
<li>情况三：整个堆的内存都耗尽了，导致日志生成失败，怎么办？<ul>
<li>应对方式：这个时候我们无法安全地分配内存，也不敢使用 stl 或者 libc 的函数，因为它们内部实现会分配堆内存。这个时候如果继续分配内存，会导致出现堆破坏或者二次崩溃的情况。Breakpad 做的比较彻底，重新封装了Linux Syscall Support，来避免直接调用 libc。</li>
</ul>
</li>
<li>情况四：堆破坏或二次崩溃导致日志生成失败，怎么办？<ul>
<li>应对方式：Breakpad 会从原进程 fork 出子进程去收集崩溃现场，此外涉及与 Java 相关的，一般也会用子进程去操作。这样即使出现二次崩溃，只是这部分的信息丢失，我们的父进程后面还可以继续获取其他的信息。在一些特殊的情况，我们还可能需要从子进程 fork 出孙进程。</li>
</ul>
</li>
</ul>
</li>
<li>选择合适的崩溃服务<ul>
<li>从产品化跟社区维护来说，Bugly 在国内做的最好。</li>
<li>从技术深度跟捕获能力来说，阿里 UC 浏览器内核团队打造的啄木鸟平台最佳。</li>
<li>还有 Google 的 Firebase 等等。</li>
</ul>
</li>
</ul>
<h3 id="如何客观地衡量崩溃"><a href="#如何客观地衡量崩溃" class="headerlink" title="如何客观地衡量崩溃"></a>如何客观地衡量崩溃</h3><ul>
<li>一些关键指标<ul>
<li>UV 崩溃率，只要用户出现过一次崩溃就会被计算到，所以 UV 崩溃率的高低会跟应用的使用时长有比较大的关系，这也是微信 UV 崩溃率在业界不算低的原因。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UV 崩溃率 &#x3D; 发生崩溃的 UV &#x2F; 登录 UV</span><br></pre></td></tr></table></figure></li>
<li>此外还有 PV 崩溃率、启动崩溃率、重复崩溃率等，计算方式大同小异</li>
</ul>
</li>
<li>KPI 导向的『崩溃率』衡量方式可能导致的问题<ul>
<li>对所有线程、任务都封装了一层 try catch，“消化”掉了所有 Java 崩溃。至于程序是否会出现其他异常表现，这是上帝要管的事情。</li>
<li>认为 Native 崩溃太难解决，所以不采集所有的 Native 崩溃。</li>
</ul>
</li>
</ul>
<h3 id="如何客观地衡量稳定性"><a href="#如何客观地衡量稳定性" class="headerlink" title="如何客观地衡量稳定性"></a>如何客观地衡量稳定性</h3><p>处理了崩溃，我们还会经常遇到 ANR（Application Not Responding，程序没有响应）这个问题。</p>
<p>通常有两种做法来发现 ANR：</p>
<ol>
<li><strong>使用 FileObserver 监听 /data/anr/traces.txt 的变化。</strong> 非常不幸的是，很多高版本的 ROM，已经没有读取这个文件的权限了。这个时候你可能只能思考其他路径，海外可以使用 Google Play 服务，而国内微信利用Hardcoder框架向厂商获取了更大的权限。</li>
<li><strong>监控消息队列的运行时间。</strong> 这个方案无法准确地判断是否真正出现了 ANR 异常，也无法得到完整的 ANR 日志。其实更应该放到卡顿的性能范畴。</li>
</ol>
<p>应用退出的几种场景</p>
<ul>
<li><strong>主动自杀。</strong> Process.killProcess()、exit() 等。</li>
<li>崩溃。出现了 Java 或 Native 崩溃。</li>
<li>系统重启；系统出现异常、断电、用户主动重启等，我们可以通过比较应用开机运行时间是否比之前记录的值更小。</li>
<li><strong>被系统杀死。</strong> 被 low memory killer 杀掉、从系统的任务管理器中划掉等。</li>
<li><strong>ANR。</strong></li>
</ul>
<p>排除主动自杀和崩溃（崩溃会单独的统计）这两种场景，还剩下三种的异常退出需要监控，以使异常捕获机制在理论上达到 100% 覆盖。</p>
<p>我们可以在应用启动的时候设定一个标志，在主动自杀或崩溃后更新标志，这样下次启动时通过检测这个标志就能确认运行期间是否发生过异常退出。</p>
<p>通过这个异常退出的检测，可以反映如 ANR、low memory killer、系统强杀、死机、断电等其他无法正常捕获到的问题。当然异常率会存在一些误报，比如用户从系统的任务管理器中划掉应用。</p>
<p>所以就得到了一个新的指标来衡量应用的稳定性，即异常率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UV 异常率 &#x3D; 发生异常退出或崩溃的 UV &#x2F; 登录 UV</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="02-崩溃优化（下）：应用崩溃了，你应该如何去分析？"><a href="#02-崩溃优化（下）：应用崩溃了，你应该如何去分析？" class="headerlink" title="02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？"></a>02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？</h1><h3 id="崩溃现场"><a href="#崩溃现场" class="headerlink" title="崩溃现场"></a>崩溃现场</h3><p>在崩溃现场应该采集哪些信息：</p>
<ol>
<li><strong>崩溃信息:</strong> 从崩溃的基本信息，我们可以对崩溃有初步的判断。<ul>
<li><strong>进程名、线程名。</strong> 崩溃的进程是前台进程还是后台进程，崩溃是不是发生在 UI 线程。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Process Name: &#39;com.sample.crash&#39;</span><br><span class="line">Thread Name: &#39;MyThread&#39;</span><br></pre></td></tr></table></figure></li>
<li><strong>崩溃堆栈和类型。</strong> 崩溃是属于 Java 崩溃、Native 崩溃，还是 ANR，对于不同类型的崩溃我们关注的点也不太一样。特别需要看崩溃堆栈的栈顶，看具体崩溃在系统的代码，还是我们自己的代码里面。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException</span><br><span class="line">    at ...TestsActivity.crashInJava(TestsActivity.java:275)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时候我们除了崩溃的线程，还希望拿到其他关键的线程的日志。就像上面的例子，虽然是 MyThread 线程崩溃，但是我也希望可以知道主线程当前的调用栈。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>系统信息:</strong> 系统的信息有时候会带有一些关键的线索，对我们解决问题有非常大的帮助。<ul>
<li><strong>Logcat。</strong> 这里包括应用、系统的运行日志。由于系统权限问题，获取到的 Logcat 可能只包含与当前 App 相关的。其中系统的 event logcat 会记录 App 运行的一些基本情况，记录在文件 /system/etc/event-log-tags 中。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">system logcat:</span><br><span class="line">10-25 17:13:47.788 21430 21430 D dalvikvm: Trying to load lib ... </span><br><span class="line">event logcat:</span><br><span class="line">10-25 17:13:47.788 21430 21430 I am_on_resume_called: 生命周期</span><br><span class="line">10-25 17:13:47.788 21430 21430 I am_low_memory: 系统内存不足</span><br><span class="line">10-25 17:13:47.788 21430 21430 I am_destroy_activity: 销毁 Activty</span><br><span class="line">10-25 17:13:47.888 21430 21430 I am_anr: ANR 以及原因</span><br><span class="line">10-25 17:13:47.888 21430 21430 I am_kill: APP 被杀以及原因</span><br></pre></td></tr></table></figure></li>
<li><strong>机型、系统、厂商、CPU、ABI、Linux 版本等。</strong> 我们会采集多达几十个维度，这对寻找共性问题会很有帮助。</li>
<li><strong>设备状态。</strong> 是否 root、是否是模拟器。一些问题是由 Xposed 或多开软件造成，对这部分问题要区别对待。</li>
</ul>
</li>
<li><strong>内存信息:</strong> OOM、ANR、虚拟内存耗尽等，很多崩溃都跟内存有直接关系。<ul>
<li><strong>系统剩余内存。</strong> 关于系统内存状态，可以直接读取文件 /proc/meminfo。当系统可用内存很小（低于 MemTotal 的 10%）时，OOM、大量 GC、系统频繁自杀拉起等问题都非常容易出现。</li>
<li><strong>应用使用内存。</strong> 包括 Java 内存、RSS（Resident Set Size）、PSS（Proportional Set Size），我们可以得出应用本身内存的占用大小和分布。PSS 和 RSS 通过 /proc/self/smap 计算，可以进一步得到例如 apk、dex、so 等更加详细的分类统计。</li>
<li><strong>虚拟内存。</strong> 虚拟内存可以通过 /proc/self/status 得到，通过 /proc/self/maps 文件可以得到具体的分布情况。有时候我们一般不太重视虚拟内存，但是很多类似 OOM、tgkill 等问题都是虚拟内存不足导致的。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name:     com.sample.name   &#x2F;&#x2F; 进程名</span><br><span class="line">FDSize:   800               &#x2F;&#x2F; 当前进程申请的文件句柄个数</span><br><span class="line">VmPeak:   3004628 kB        &#x2F;&#x2F; 当前进程的虚拟内存峰值大小</span><br><span class="line">VmSize:   2997032 kB        &#x2F;&#x2F; 当前进程的虚拟内存大小</span><br><span class="line">Threads:  600               &#x2F;&#x2F; 当前进程包含的线程个数</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般来说，对于 32 位进程，如果是 32 位的 CPU，虚拟内存达到 3GB 就可能会引起内存申请失败的问题。如果是 64 位的 CPU，虚拟内存一般在 3～4GB 之间。当然如果我们支持 64 位进程，虚拟内存就不会成为问题。Google Play 要求 2019 年 8 月一定要支持 64 位，在国内虽然支持 64 位的设备已经在 90% 以上了，但是商店都不支持区分 CPU 架构类型发布，普及起来需要更长的时间。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>资源信息:</strong> 有的时候我们会发现应用堆内存和设备内存都非常充足，还是会出现内存分配失败的情况，这跟资源泄漏可能有比较大的关系。<ul>
<li><strong>文件句柄 fd。</strong> 文件句柄的限制可以通过 /proc/self/limits 获得，一般单个进程允许打开的最大文件句柄个数为 1024。但是如果文件句柄超过 800 个就比较危险，需要将所有的 fd 以及对应的文件名输出到日志中，进一步排查是否出现了有文件或者线程的泄漏。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opened files count 812:</span><br><span class="line">0 -&gt; &#x2F;dev&#x2F;null</span><br><span class="line">1 -&gt; &#x2F;dev&#x2F;log&#x2F;main4 </span><br><span class="line">2 -&gt; &#x2F;dev&#x2F;binder</span><br><span class="line">3 -&gt; &#x2F;data&#x2F;data&#x2F;com.crash.sample&#x2F;files&#x2F;test.config</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><strong>线程数。</strong> 当前线程数大小可以通过上面的 status 文件得到，一个线程可能就占 2MB 的虚拟内存，过多的线程会对虚拟内存和文件句柄带来压力。根据经验来说，如果线程数超过 400 个就比较危险。需要将所有的线程 id 以及对应的线程名输出到日志中，进一步排查是否出现了线程相关的问题。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">threads count 412:               </span><br><span class="line">1820 com.sample.crashsdk                         </span><br><span class="line">1844 ReferenceQueueD                                             </span><br><span class="line">1869 FinalizerDaemon   </span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><strong>JNI。</strong> JNI 可能出现引用失效、引用爆表等一些崩溃。我们可以通过 DumpReferenceTables 统计 JNI 的引用表，进一步分析是否出现了 JNI 泄漏等问题。</li>
</ul>
</li>
<li><strong>应用信息:</strong> 除了系统，其实我们的应用更懂自己，可以留下很多相关的信息。<ul>
<li><strong>崩溃场景。</strong> 崩溃发生在哪个 Activity 或 Fragment，发生在哪个业务中。</li>
<li><strong>关键操作路径。</strong> 不同于开发过程详细的打点日志，我们可以记录关键的用户操作路径，这对我们复现崩溃会有比较大的帮助。</li>
<li><strong>其他自定义信息。</strong> 不同的应用关心的重点可能不太一样，比如网易云音乐会关注当前播放的音乐，QQ 浏览器会关注当前打开的网址或视频。此外例如运行时间、是否加载了补丁、是否是全新安装或升级等信息也非常重要。<blockquote>
<p>除了上面这些通用的信息外，针对特定的一些崩溃，我们可能还需要获取类似磁盘空间、电量、网络使用等特定信息。所以说一个好的崩溃捕获工具，会根据场景为我们采集足够多的信息，让我们有更多的线索去分析和定位问题。当然数据的采集需要注意用户隐私，做到足够强度的加密和脱敏。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="崩溃分析"><a href="#崩溃分析" class="headerlink" title="崩溃分析"></a>崩溃分析</h3><ol>
<li><strong>第一步：确定重点</strong>，在日志中找到重要的信息，对问题有一个大致判断。<ol>
<li><strong>确认严重程度。</strong> 优先解决 Top 崩溃或者对业务有重大影响，例如启动、支付过程的崩溃。</li>
<li><strong>崩溃基本信息。</strong> 确定崩溃的类型以及异常描述，对崩溃有大致的判断。<ul>
<li>Java 崩溃。Java 崩溃类型比较明显，这个时候需要去进一步查看日志中的 “内存信息”和“资源信息”。</li>
<li>Native 崩溃。需要观察 signal、code、fault addr 等内容，以及崩溃时 Java 的堆栈。</li>
<li>ANR。先看看主线程的堆栈，是否是因为锁等待导致。接着看看 ANR 日志中 iowait、CPU、GC、system server 等信息，进一步确定是 I/O 问题，或是 CPU 竞争问题，还是由于大量 GC 导致卡死。</li>
</ul>
</li>
<li><strong>Logcat。</strong> Logcat 一般会存在一些有价值的线索，日志级别是 Warning、Error 的需要特别注意。从 Logcat 中我们可以看到当时系统的一些行为跟手机的状态，例如出现 ANR 时，会有“am_anr”；App 被杀时，会有“am_kill”。不同的系统、厂商输出的日志有所差别，当从一条崩溃日志中无法看出问题的原因，或者得不到有用信息时，不要放弃，建议查看相同崩溃点下的更多崩溃日志。</li>
<li><strong>各个资源情况。</strong> 结合崩溃的基本信息，我们接着看看是不是跟 “内存信息” 有关，是不是跟“资源信息”有关。比如是物理内存不足、虚拟内存不足，还是文件句柄 fd 泄漏了。</li>
</ol>
</li>
<li><strong>第二步：查找共性</strong>，如果使用了上面的方法还是不能有效定位问题，我们可以尝试查找这类崩溃有没有什么共性。找到了共性，也就可以进一步找到差异，离解决问题也就更进一步。<blockquote>
<p>机型、系统、ROM、厂商、ABI，这些采集到的系统信息都可以作为维度聚合，共性问题例如是不是因为安装了 Xposed，是不是只出现在 x86 的手机，是不是只有三星这款机型，是不是只在 Android 5.0 的系统上。应用信息也可以作为维度来聚合，比如正在打开的链接、正在播放的视频、国家、地区等。</p>
</blockquote>
</li>
<li><strong>第三步：尝试复现</strong>，为了进一步确认更多信息，就需要尝试复现崩溃。如果我们对崩溃完全没有头绪，也希望通过用户操作路径来尝试重现，然后再去分析崩溃原因。<br><strong>复现中有一种疑难问题，即系统崩溃，针对此类型我们可以通过如下方式解决:</strong><ol>
<li><strong>查找可能的原因。</strong> 通过上面的共性归类，我们先看看是某个系统版本的问题，还是某个厂商特定 ROM 的问题。</li>
<li><strong>尝试规避。</strong> 查看可疑的代码调用，是否使用了不恰当的 API，是否可以更换其他的实现方式规避。</li>
<li><strong>Hook 解决。</strong> 这里分为 Java Hook 和 Native Hook。</li>
</ol>
</li>
</ol>
<hr>
<h1 id="03-内存优化（上）：4GB内存时代，再谈内存优化"><a href="#03-内存优化（上）：4GB内存时代，再谈内存优化" class="headerlink" title="03 | 内存优化（上）：4GB内存时代，再谈内存优化"></a>03 | 内存优化（上）：4GB内存时代，再谈内存优化</h1><h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><h4 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h4><p><img src="https://static001.geekbang.org/resource/image/c2/ce/c26a9351868bb82abd7ada028275f5ce.png" alt=""></p>
<ul>
<li><strong>异常</strong><ul>
<li>OOM</li>
<li>内存分配失败</li>
<li>因为整体内存不足导致应用被杀死、设备重启等</li>
</ul>
</li>
<li><strong>卡顿</strong><ul>
<li>Java 内存不足会导致频繁 GC，这个问题在 Dalvik 虚拟机会更加明显。而 ART 虚拟机在内存管理跟回收策略上都做大量优化，内存分配和 GC 效率相比提升了 5～10 倍。<ul>
<li>如果想具体测试 GC 的性能，例如暂停挂起时间、总耗时、GC 吞吐量，我们可以通过发送SIGQUIT 信号获得 ANR 日志。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell kill -S QUIT PID</span><br><span class="line">adb pull &#x2F;data&#x2F;anr&#x2F;traces.txt</span><br></pre></td></tr></table></figure>
  它包含一些 ANR 转储信息以及 GC 的详细性能信息。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sticky concurrent mark sweep paused:	Sum: 5.491ms 99% C.I. 1.464ms-2.133ms Avg: 1.830ms Max: 2.133ms     &#x2F;&#x2F; GC 暂停时间</span><br><span class="line"></span><br><span class="line">Total time spent in GC: 502.251ms     &#x2F;&#x2F; GC 总耗时</span><br><span class="line">Mean GC size throughput: 92MB&#x2F;s       &#x2F;&#x2F; GC 吞吐量</span><br><span class="line">Mean GC object throughput: 1.54702e+06 objects&#x2F;s</span><br></pre></td></tr></table></figure></li>
<li>另外我们还可以使用 systrace 来观察 GC 的性能耗时。</li>
</ul>
</li>
<li>物理内存不足时系统会触发 low memory killer 机制，系统负载过高是造成卡顿的另外一个原因。</li>
</ul>
</li>
</ul>
<h4 id="两个误区"><a href="#两个误区" class="headerlink" title="两个误区"></a>两个误区</h4><ul>
<li><strong>内存占用越少越好:</strong> 应用是否占用了过多的内存，跟设备、系统和当时情况有关，而不是一个绝对的数值。当系统内存充足的时候，我们可以多用一些获得更好的性能。当系统内存不足的时候，希望可以做到“用时分配，及时释放”，就像下面这张图一样。<br>  <img src="https://static001.geekbang.org/resource/image/07/97/0739a98bfafdd9f59539ddbbf403f097.png" alt=""></li>
<li><strong>Native 内存不用管:</strong> 当系统物理内存不足时，low memory killer 开始杀进程，从后台、桌面、服务、前台，直到手机重启。系统构想的场景就像下面这张图描述的一样，大家有条不絮的按照优先级排队等着被 kill。<br>  <img src="https://static001.geekbang.org/resource/image/b8/98/b8d160f8d487bcb377e0c38ff9a0ac98.png" alt=""><blockquote>
<p>low memory killer 的设计，是假定我们都遵守 Android 规范，但并没有考虑到中国国情。国内很多应用就像是打不死的小强，杀死一个拉起五个。频繁的杀死、拉起进程，又会导致 system server 卡死。当然在 Android 8.0 以后应用保活变得困难很多，但依然有一些方法可以突破。</p>
</blockquote>
</li>
</ul>
<h4 id="Android-Bitmap-内存分配的变化"><a href="#Android-Bitmap-内存分配的变化" class="headerlink" title="Android Bitmap 内存分配的变化"></a>Android Bitmap 内存分配的变化</h4><ul>
<li><strong>Android 3.0 之前:</strong> Bitmap 对象放在 Java 堆，而像素数据是放在 Native 内存中。如果不手动调用 recycle，Bitmap Native 内存的回收完全依赖 finalize 函数回调，熟悉 Java 的同学应该知道，这个时机不太可控。</li>
<li><strong>Android 3.0～Android 7.0:</strong> 将 Bitmap 对象和像素数据统一放到 Java 堆中，这样就算我们不调用 recycle，Bitmap 内存也会随着对象一起被回收。不过 Bitmap 是内存消耗的大户，把它的内存放到 Java 堆中似乎不是那么美妙。即使是最新的华为 Mate 20，最大的 Java 堆限制也才到 512MB，可能我的物理内存还有 5GB，但是应用还是会因为 Java 堆内存不足导致 OOM。Bitmap 放到 Java 堆的另外一个问题会引起大量的 GC，对系统内存也没有完全利用起来。</li>
<li><strong>Android 8.0:</strong> 使用 NativeAllocationRegistry 辅助回收 Native 内存。可以做到将 Bitmap 内存放到 Native 中，并且和对象一起快速释放，同时 GC 的时候也能考虑这些内存防止被滥用。Android 8.0 还新增了硬件位图 Hardware Bitmap，它可以减少图片内存并提升绘制效率。</li>
</ul>
<h4 id="如何将图片放到-Native-内存"><a href="#如何将图片放到-Native-内存" class="headerlink" title="如何将图片放到 Native 内存"></a>如何将图片放到 Native 内存</h4><p>在 Android 8.0 后，图片默认放在 Native 内存。Fresco 图片库在 Dalvik 会把图片放到 Native 内存中。事实上在 Android 5.0～Android 7.0，也能做到相同的效果，只是流程相对复杂一些。</p>
<ol>
<li>通过直接调用 libandroid_runtime.so 中 Bitmap 的构造函数，可以得到一张空的 Bitmap 对象，而它的内存是放到 Native 堆中。但是不同 Android 版本的实现有那么一点差异，这里都需要适配。</li>
<li>通过系统的方法创建一张普通的 Java Bitmap。</li>
<li>将 Java Bitmap 的内容绘制到之前申请的空的 Native Bitmap 中。</li>
<li>将申请的 Java Bitmap 释放，实现图片内存的“偷龙转凤”。</li>
</ol>
<p>对应代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 申请一张空的 Native Bitmap</span></span><br><span class="line">Bitmap nativeBitmap = nativeCreateBitmap(dstWidth, dstHeight, nativeConfig, <span class="number">22</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2. 申请一张普通的 Java Bitmap</span></span><br><span class="line">Bitmap srcBitmap = BitmapFactory.decodeResource(res, id);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3. 使用 Java Bitmap 将内容绘制到 Native Bitmap 中</span></span><br><span class="line">mNativeCanvas.setBitmap(nativeBitmap);</span><br><span class="line">mNativeCanvas.drawBitmap(srcBitmap, mSrcRect, mDstRect, mPaint);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4. 释放 Java Bitmap 内存</span></span><br><span class="line">srcBitmap.recycle();</span><br><span class="line">srcBitmap = <span class="keyword">null</span>；</span><br></pre></td></tr></table></figure>

<h3 id="测量方法"><a href="#测量方法" class="headerlink" title="测量方法"></a>测量方法</h3><ul>
<li><strong>Java 内存分配:</strong> 最常用的有 Allocation Tracker 和 MAT 这两个工具。<ul>
<li><strong>Allocation Tracker 的三个缺点</strong><ul>
<li>获取的信息过于分散，中间夹杂着不少其他的信息，很多信息不是应用申请的，可能需要进行不少查找才能定位到具体的问题。</li>
<li>跟 Traceview 一样，无法做到自动化分析，每次都需要开发者手工开始 / 结束，这对于某些问题的分析可能会造成不便，而且对于批量分析来说也比较困难。</li>
<li>虽然在 Allocation Tracking 的时候，不会对手机本身的运行造成过多的性能影响，但是在停止的时候，直到把数据 dump 出来之前，经常会把手机完全卡死，如果时间过长甚至会直接 ANR。</li>
</ul>
</li>
<li><strong>自定义 Allocation Tracker</strong>，我们希望可以做到脱离 Android Studio，实现一个自定义的“Allocation Tracker”，实现对象内存的自动化分析。通过这个工具可以获取所有对象的申请信息（大小、类型、堆栈等），可以找到一段时间内那些对象占用了大量的内存。但是这个方法需要考虑的兼容性问题会比较多。<blockquote>
<p>任何一个工具如果只需要做到线下自动化测试，实现起来会相对简单，但想要移植到线上使用，那就要更加关注兼容性、稳定性和性能，付出的努力要远远高于实验室方案。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>Native 内存分配</strong><ul>
<li><strong>AddressSanitize:</strong> 遵循“谁最痛，谁最需要，谁优化”，在 Android 8.0 之后，我们可以根据这个 <a href="http://github.com/google/sanitizers/wiki/AddressSanitizerOnAndroid" target="_blank" rel="noopener">指南</a> 来使用 AddressSanitize。</li>
<li><strong>Malloc 调试:</strong> Malloc 调试可以帮助我们去调试 Native 内存的一些使用问题，例如堆破坏、内存泄漏、非法地址等。Android 8.0 之后支持在非 root 的设备做 Native 内存调试，不过跟 AddressSanitize 一样，需要通过wrap.sh做包装。</li>
<li><strong>Malloc 钩子:</strong> Malloc 钩子是在 Android P 之后，Android 的 libc 支持拦截在程序执行期间发生的所有分配 / 释放调用，这样我们就可以构建出自定义的内存检测工具。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="04-内存优化（下）：内存优化这件事，应该从哪里着手？"><a href="#04-内存优化（下）：内存优化这件事，应该从哪里着手？" class="headerlink" title="04 | 内存优化（下）：内存优化这件事，应该从哪里着手？"></a>04 | 内存优化（下）：内存优化这件事，应该从哪里着手？</h1><h3 id="内存优化探讨"><a href="#内存优化探讨" class="headerlink" title="内存优化探讨"></a>内存优化探讨</h3><ol>
<li><strong>设备分级:</strong> 内存优化首先需要根据设备环境来综合考虑，当然这需要有一个良好的架构设计支撑，在架构设计时需要做到以下几点。<ul>
<li><strong>设备分级。</strong> 使用类似 device-year-class 的策略对设备分级，对于低端机用户可以关闭复杂的动画，或者是某些功能。</li>
<li><strong>缓存管理。</strong> 我们需要有一套统一的缓存管理机制，可以适当地使用内存；当“系统有难”时，也要义不容辞地归还。我们可以使用 OnTrimMemory 回调，根据不同的状态决定释放多少内存。对于大项目来说，可能存在几十上百个模块，统一缓存管理可以更好地监控每个模块的缓存大小。</li>
<li><strong>进程模型。</strong> 一个空的进程也会占用 10MB 的内存，而有些应用启动就有十几个进程，甚至有些应用已经从双进程保活升级到四进程保活，所以减少应用启动的进程数、减少常驻进程、有节操的保活，对低端机内存优化非常重要。</li>
<li><strong>安装包大小。</strong> 安装包中的代码、资源、图片以及 so 库的体积，跟它们占用的内存有很大的关系。一个 80MB 的应用很难在 512MB 内存的手机上流畅运行。这种情况我们需要考虑针对低端机用户推出 4MB 的轻量版本，例如 Facebook Lite、今日头条极速版都是这个思路。</li>
</ul>
</li>
<li><strong>Bitmap 优化</strong><ul>
<li><strong>统一图片库。</strong> 图片内存优化的前提是收拢图片的调用，这样我们可以做整体的控制策略。可以使用 Glide、Fresco 或者采取自研都可以，而且需要进一步将所有 Bitmap.createBitmap、BitmapFactory 相关的接口也一并收拢。</li>
<li><strong>统一监控。</strong><ul>
<li><strong>大图片监控。</strong> 我们需要注意某张图片内存占用是否过大，例如长宽远远大于 View 甚至是屏幕的长宽。<ul>
<li>在开发过程中，如果检测到不合规的图片使用，应该立即弹出对话框提示图片所在的 Activity 和堆栈，让开发同学更快发现并解决问题。</li>
<li>在灰度和线上环境下可以将异常信息上报到后台，我们可以计算有多少比例的图片会超过屏幕的大小，也就是图片的“超宽率”。</li>
</ul>
</li>
<li><strong>重复图片监控。</strong> 重复图片指的是 Bitmap 的像素数据完全一致，但是有多个不同的对象存在。这个监控不需要太多的样本量，一般只在内部使用。</li>
<li><strong>图片总内存。</strong> 通过收拢图片使用，我们还可以统计应用所有图片占用的内存。<ul>
<li>在线上就可以按不同的系统、屏幕分辨率等维度去分析图片内存的占用情况。</li>
<li>在 OOM 崩溃的时候，也可以把图片占用的总内存、Top N 图片的内存都写到崩溃日志中，帮助我们排查问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>内存泄漏</strong><ul>
<li><strong>Java 内存泄漏。</strong> 建立类似 LeakCanary 自动化检测方案，至少做到 Activity 和 Fragment 的泄漏检测。<ul>
<li>在开发过程，我们希望出现泄漏时可以弹出对话框，让开发者更加容易去发现和解决问题。</li>
<li>内存泄漏监控放到线上并不容易，我们可以对生成的 Hprof 内存快照文件做一些优化，裁剪大部分图片对应的 byte 数组减少文件大小。比如一个 100MB 的文件裁剪后一般只剩下 30MB 左右，使用 7zip 压缩最后小于 10MB，增加了文件上传的成功率。</li>
</ul>
</li>
<li><strong>OOM 监控。</strong> 美团有一个 Android 内存泄露自动化链路分析组件 Probe，它在发生 OOM 的时候生成 Hprof 内存快照，然后通过单独进程对这个文件做进一步的分析。<ul>
<li>在线上使用 Probe 的风险还是比较大，在崩溃的时候生成内存快照有可能会导致二次崩溃，而且部分手机生成 Hprof 快照可能会耗时几分钟，这对用户造成的体验影响会比较大。</li>
<li>另外，部分 OOM 是因为虚拟内存不足导致，这块需要具体问题具体分析。</li>
</ul>
</li>
<li><strong>Native 内存泄漏监控。</strong> 还并没有非常稳定的方案。</li>
<li><strong>针对无法重编 so 的情况，</strong> 使用了 PLT Hook 拦截库的内存分配函数，其中 PLT Hook 是 Native Hook 的一种方案，后面我们还会讲到。然后重定向到我们自己的实现后记录分配的内存地址、大小、来源 so 库路径等信息，定期扫描分配与释放是否配对，对于不配对的分配输出我们记录的信息。</li>
<li><strong>针对可重编的 so 情况，</strong> 通过 GCC 的“-finstrument-functions”参数给所有函数插桩，桩中模拟调用栈入栈出栈操作；通过 ld 的“–wrap”参数拦截内存分配和释放函数，重定向到我们自己的实现后记录分配的内存地址、大小、来源 so 以及插桩记录的调用栈此刻的内容，定期扫描分配与释放是否配对，对于不配对的分配输出我们记录的信息。</li>
</ul>
</li>
</ol>
<h3 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h3><p>前面提到的内存泄漏的监控存在一些性能的问题，一般只会对内部人员和极少部分的用户开启。在线上我们需要通过其他更有效的方式去监控内存相关的问题。</p>
<ol>
<li><strong>采集方式:</strong> 用户在前台的时候，可以每 5 分钟采集一次 PSS、Java 堆、图片总内存。建议采样只统计部分用户，需要注意的是要按照用户抽样，而不是按次抽样。简单来说一个用户如果命中采集，那么在一天内都要持续采集数据。</li>
<li><strong>计算指标:</strong> 通过上面的数据，我们可以计算下面一些内存指标。一般客户端只上报数据，所有计算都在后台处理，这样可以做到灵活多变。<ul>
<li><strong>内存异常率:</strong> 可以反映内存占用的异常情况，如果出现新的内存使用不当或内存泄漏的场景，这个指标会有所上涨。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存 UV 异常率 &#x3D; PSS 超过 400MB 的 UV &#x2F; 采集 UV</span><br></pre></td></tr></table></figure></li>
<li><strong>触顶率:</strong> 可以反映 Java 内存的使用情况，如果超过 85% 最大堆限制，GC 会变得更加频繁，容易造成 OOM 和卡顿。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存 UV 触顶率 &#x3D; Java 堆占用超过最大堆限制的 85% 的 UV &#x2F; 采集 UV</span><br></pre></td></tr></table></figure>
  其中是否触顶可以通过下面的方法计算得到。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long javaMax &#x3D; runtime.maxMemory();</span><br><span class="line">long javaTotal &#x3D; runtime.totalMemory();</span><br><span class="line">long javaUsed &#x3D; javaTotal - runtime.freeMemory();</span><br><span class="line">&#x2F;&#x2F; Java 内存使用超过最大限制的 85%</span><br><span class="line">float proportion &#x3D; (float) javaUsed &#x2F; javaMax;</span><br></pre></td></tr></table></figure></li>
<li><strong>其他指标:</strong> 平均 PSS、平均 Java 内存、平均图片占用等指标，它们可以反映内存的平均情况。通过平均内存和分区间内存占用这些指标，我们可以通过版本对比来监控有没有新增内存相关的问题。</li>
<li><strong>按时间纬度查看:</strong> 因为上报了前台时间，我们还可以按照时间维度看应用内存的变化曲线。比如可以观察一下我们的应用是不是真正做到了“用时分配，及时释放”。如果需要，我们还可以实现按照场景来对比内存的占用。</li>
</ul>
</li>
<li><strong>GC 监控</strong><ul>
<li><strong>实现 GC 监控:</strong> 在实验室或者内部试用环境，我们也可以通过 Debug.startAllocCounting 来监控 Java 内存分配和 GC 的情况，需要注意的是这个选项对性能有一定的影响，虽然目前还可以使用，但已经被 Android 标记为 deprecated。<ul>
<li>通过监控，我们可以拿到内存分配的次数和大小，以及 GC 发起次数等信息。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long allocCount &#x3D; Debug.getGlobalAllocCount();</span><br><span class="line">long allocSize &#x3D; Debug.getGlobalAllocSize();</span><br><span class="line">long gcCount &#x3D; Debug.getGlobalGcInvocationCount();</span><br></pre></td></tr></table></figure></li>
<li>在 Android 6.0 之后系统可以拿到更加精准的 GC 信息。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 运行的 GC 次数</span><br><span class="line">Debug.getRuntimeStat(&quot;art.gc.gc-count&quot;);</span><br><span class="line">&#x2F;&#x2F; GC 使用的总耗时，单位是毫秒</span><br><span class="line">Debug.getRuntimeStat(&quot;art.gc.gc-time&quot;);</span><br><span class="line">&#x2F;&#x2F; 阻塞式 GC 的次数</span><br><span class="line">Debug.getRuntimeStat(&quot;art.gc.blocking-gc-count&quot;);</span><br><span class="line">&#x2F;&#x2F; 阻塞式 GC 的总耗时</span><br><span class="line">Debug.getRuntimeStat(&quot;art.gc.blocking-gc-time&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>需要特别注意阻塞式 GC 的次数和耗时，因为它会暂停应用线程，可能导致应用发生卡顿。</li>
<li>可以更加细粒度地分应用场景统计，例如启动、进入朋友圈、进入聊天页面等关键场景。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="05-卡顿优化（上）：你要掌握的卡顿分析方法"><a href="#05-卡顿优化（上）：你要掌握的卡顿分析方法" class="headerlink" title="05 | 卡顿优化（上）：你要掌握的卡顿分析方法"></a>05 | 卡顿优化（上）：你要掌握的卡顿分析方法</h1><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="CPU-时间"><a href="#CPU-时间" class="headerlink" title="CPU 时间"></a>CPU 时间</h4><p>造成卡顿的原因可能有千百种，不过最终都会反映到CPU 时间上。我们可以把 CPU 时间分为两种：</p>
<ul>
<li><strong>用户时间:</strong> 用户时间就是执行用户态应用程序代码所消耗的时间。</li>
<li><strong>系统时间:</strong> 系统时间就是执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。</li>
</ul>
<h4 id="CPU-性能"><a href="#CPU-性能" class="headerlink" title="CPU 性能"></a>CPU 性能</h4><ul>
<li>我们可以通过下面的方法获得设备的 CPU 信息。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 CPU 核心数</span><br><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;possible  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取某个 CPU 的频率</span><br><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;cpuinfo_max_freq</span><br></pre></td></tr></table></figure></li>
<li>从 CPU 到 GPU 再到 AI 芯片，随着手机 CPU 整体性能的飞跃，医疗诊断、图像超清化等一些 AI 应用场景也可以在移动端更好地落地。最近边缘计算也越来越多的被提及，我们希望可以更大程度地利用移动端的计算能力来降低高昂的服务器成本。</li>
<li>在开发过程中，我们需要根据设备 CPU 性能来“看菜下饭”，例如:<ul>
<li>线程池使用线程数根据 CPU 的核心数</li>
<li>一些高级的 AI 功能只在主频比较高或者带有 NPU 的设备开启</li>
</ul>
</li>
</ul>
<h4 id="卡顿问题分析指标"><a href="#卡顿问题分析指标" class="headerlink" title="卡顿问题分析指标"></a>卡顿问题分析指标</h4><p><strong>CPU 使用率</strong></p>
<ul>
<li>通过 <code>/proc/stat</code> 得到整个系统的 CPU 使用情况</li>
<li>通过 <code>/proc/[pid]/stat</code> 可以得到某个进程的 CPU 使用情况。</li>
</ul>
<p>stat 文件中比较重要的字段有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proc&#x2F;self&#x2F;stat:</span><br><span class="line">  utime:       用户时间，反应用户代码执行的耗时  </span><br><span class="line">  stime:       系统时间，反应系统调用执行的耗时</span><br><span class="line">  majorFaults：需要硬盘拷贝的缺页次数</span><br><span class="line">  minorFaults：无需硬盘拷贝的缺页次数</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 CPU 使用率长期大于 60% ，表示系统处于繁忙状态，就需要进一步分析用户时间和系统时间的比例。</li>
<li>对于普通应用程序，系统时间不会长期高于 30%，如果超过这个值，我们就应该进一步检查是 I/O 过多，还是其他的系统调用问题。</li>
</ul>
<p><strong>CPU 饱和度</strong><br>查看 CPU 饱和度相关参数的指令：</p>
<ul>
<li>top 命令可以帮助我们查看哪个进程是 CPU 的消耗大户</li>
<li>vmstat 命令可以实时动态监视操作系统的虚拟内存和 CPU 活动</li>
<li>strace 命令可以跟踪某个进程中所有的系统调用</li>
</ul>
<p>CPU 饱和度首先会跟应用的线程数有关，如果启动的线程过多，容易导致系统不断地切换执行的线程，把大量的时间浪费在上下文切换，我们知道每一次 CPU 上下文切换都需要刷新寄存器和计数器，至少需要几十纳秒的时间。</p>
<ul>
<li>我们可以通过使用 <code>vmstat</code> 命令或者 <code>/proc/[pid]/schedstat</code> 文件来查看 <strong>CPU 上下文切换次数</strong>，这里特别需要注意 <code>nr_involuntary_switches</code> 被动切换的次数。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proc&#x2F;self&#x2F;sched:</span><br><span class="line">nr_voluntary_switches：     </span><br><span class="line">主动上下文切换次数，因为线程无法获取所需资源导致上下文切换，最普遍的是 IO。    </span><br><span class="line">nr_involuntary_switches：   </span><br><span class="line">被动上下文切换次数，线程被系统强制调度导致上下文切换，例如大量线程在抢占 CPU。</span><br><span class="line">se.statistics.iowait_count：IO 等待的次数</span><br><span class="line">se.statistics.iowait_sum：  IO 等待的时间</span><br></pre></td></tr></table></figure></li>
<li>通过 <code>uptime</code> 命令可以检查 CPU 在 1 分钟、5 分钟和 15 分钟内的<strong>平均负载</strong>。比如一个 4 核的 CPU，如果当前平均负载是 8，这意味着每个 CPU 上有一个线程在运行，还有一个线程在等待。一般平均负载建议控制在“0.7 × 核数”以内。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00:02:39 up 7 days, 46 min,  0 users,</span><br><span class="line">load average: 13.91, 14.70, 14.32</span><br></pre></td></tr></table></figure></li>
<li>另外一个会影响 CPU 饱和度的是<strong>线程优先级</strong>，线程优先级会影响 Android 系统的调度策略，它主要由 nice 和 cgroup 类型共同决定。nice 值越低，抢占 CPU 时间片的能力越强。当 CPU 空闲时，线程的优先级对执行效率的影响并不会特别明显，但在 CPU 繁忙的时候，线程调度会对执行效率有非常大的影响。<br>  <img src="https://static001.geekbang.org/resource/image/52/0b/526d72f3dbc70ef45c00e7c0e7bdd80b.png" alt=""><ul>
<li>需要注意是否存在高优先级的线程空等低优先级线程，例如主线程等待某个后台线程的锁。从应用程序的角度来看，无论是用户时间、系统时间，还是等待 CPU 的调度，都是程序运行花费的时间。</li>
</ul>
</li>
</ul>
<h3 id="Android-卡顿排查工具"><a href="#Android-卡顿排查工具" class="headerlink" title="Android 卡顿排查工具"></a>Android 卡顿排查工具</h3><p>按照上面各种 Linux 命令组合来排查问题太麻烦了，需要更简单的、图形化的操作界面。</p>
<p>Traceview 和 systrace 都是我们比较熟悉的排查卡顿的工具，从实现上这些工具分为两个流派。</p>
<ul>
<li><strong>instrument</strong>。获取一段时间内所有函数的调用过程，可以通过分析这段时间内的函数调用流程，再进一步分析待优化的点。</li>
<li><strong>sample</strong>。有选择性或者采用抽样的方式观察某些函数调用过程，可以通过这些有限的信息推测出流程中的可疑点，然后再继续细化分析。</li>
</ul>
<h4 id="Traceview"><a href="#Traceview" class="headerlink" title="Traceview"></a>Traceview</h4><p>Traceview 利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中。</p>
<ul>
<li>流派<ul>
<li>Traceview 属于 instrument 类型，它可以用来查看整个过程有哪些函数调用。</li>
<li>在 Android 5.0 之后，新增了 startMethodTracingSampling 方法，即 sample 流派</li>
</ul>
</li>
<li>缺点<ul>
<li>性能开销过大，有时无法反映真实的情况。比如一个函数本身的耗时是 1 秒，开启 Traceview 后可能会变成 5 秒，而且这些函数的耗时变化并不是成比例放大。</li>
<li>新增了 sample 类型后，就需要我们在开销和信息丰富度之间做好权衡。</li>
<li>无论是哪种的 Traceview 对 release 包支持的都不太好，例如无法反混淆。</li>
</ul>
</li>
</ul>
<h4 id="Nanoscope"><a href="#Nanoscope" class="headerlink" title="Nanoscope"></a>Nanoscope</h4><p>Uber 开源的 Nanoscope，它的实现原理是直接修改 Android 虚拟机源码，在 ArtMethod 执行入口和执行结束位置增加埋点代码，将所有的信息先写到内存，等到 trace 结束后才统一生成结果文件。</p>
<ul>
<li>流派<ul>
<li>Nanoscope 属于 instrument 类型</li>
</ul>
</li>
<li>优点<ul>
<li>应用不会因为开启 Nanoscope 而感到卡顿</li>
<li>它可以支持分析任意一个应用，可用于做竞品分析。</li>
<li>Uber 写了一系列自动化脚本协助整个流程，使用起来还算简单。</li>
<li>Nanoscope 生成的是符合 Chrome tracing 规范的 HTML 文件。我们可以通过脚本来实现两个功能：<ul>
<li>反混淆。通过 mapping 自动反混淆结果文件。</li>
<li>自动化分析。传入相同的起点和终点，实现两个结果文件的 diff，自动分析差异点。</li>
</ul>
</li>
</ul>
</li>
<li>缺点<ul>
<li>trace 结束生成结果文件这一步需要的时间比较长</li>
<li>需要自己刷 ROM，并且当前只支持 Nexus 6P，或者采用其提供的 x86 架构的模拟器。</li>
<li>默认只支持主线程采集，其他线程需要代码手动设置。考虑到内存大小的限制，每个线程的内存数组只能支持大约 20 秒左右的时间段。</li>
</ul>
</li>
</ul>
<blockquote>
<p>我们有时候为了实现更多定制化功能或者拿到更加丰富的信息，这个时候不得不使用定制 ROM 的方式。而 Nanoscope 恰恰是一个很好的工具，可以让我们更方便地实现定制 ROM。</p>
</blockquote>
<h4 id="systrace"><a href="#systrace" class="headerlink" title="systrace"></a>systrace</h4><p><img src="https://static001.geekbang.org/resource/image/12/15/127526ef09381587f48fb16187b91715.jpg" alt=""><br>systrace是 Android 4.1 新增的性能分析工具。systrace 利用了 Linux 的 ftrace 调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里加了一些性能监控的埋点。Android 在 ftrace 的基础上封装了atrace，并增加了更多特有的探针，例如 Graphics、Activity Manager、Dalvik VM、System Server 等。</p>
<ul>
<li>流派<ul>
<li>systrace 工具只能监控特定系统调用的耗时情况，所以它是属于 sample 类型。</li>
</ul>
</li>
<li>优点<ul>
<li>性能开销非常低。</li>
<li>我们可以在 systrace 基础上增加应用程序耗时的监控。我们可以在编译时给每个函数插桩，也就是在重要函数的入口和出口分别增加 Trace.beginSection 和 Trace.endSection。当然出于性能的考虑，我们会过滤大部分指令数比较少的函数。通过这样方式的好处有：<ul>
<li>可以看到整个流程系统和应用程序的调用流程。包括系统关键线程的函数调用，例如渲染耗时、线程锁，GC 耗时等。</li>
<li>性能损耗可以接受。由于过滤了大部分的短函数，而且没有放大 I/O，所以整个运行耗时不到原来的两倍，基本可以反映真实情况。</li>
</ul>
</li>
<li>systrace 生成的也是 HTML 格式的结果，我们利用跟 Nanoscope 相似方式实现对反混淆的支持。</li>
</ul>
</li>
<li>缺点<ul>
<li>不支持应用程序代码的耗时分析，所以在使用时有一些局限性。</li>
</ul>
</li>
</ul>
<h4 id="Simpleperf"><a href="#Simpleperf" class="headerlink" title="Simpleperf"></a>Simpleperf</h4><p><img src="https://static001.geekbang.org/resource/image/de/5f/de8b2064c4fee25166602781fbff915f.jpg" alt=""><br>Android 5.0 新增了Simpleperf性能分析工具，它利用 CPU 的性能监控单元（PMU）提供的硬件 perf 事件。</p>
<ul>
<li>流派<ul>
<li>sample</li>
</ul>
</li>
<li>优点<ul>
<li>性能开销非常低</li>
<li>Simpleperf 可以看到所有的 Native 代码的耗时，有时候一些 Android 系统库的调用对分析问题有比较大的帮助，例如加载 dex、verify class 的耗时等。</li>
</ul>
</li>
<li>缺点<ul>
<li>Simpleperf 的反混淆比较难实现，因为在函数聚合后会抛弃参数，无法直接对生成的 HTML 文件做处理。当然我们也可以根据各个工具的实现思路，自己重新打造一套支持非 debugable 的自动化测试工具。</li>
</ul>
</li>
<li>Simpleperf 发展的几个阶段（Simpleperf 同时封装了 systrace 的监控功能，并经历了 Android 几个版本的优化）<ol>
<li>在 Android M 和以前，Simpleperf 不支持 Java 代码分析。</li>
<li>在 Android O 和以前，需要手动指定编译 OAT 文件。</li>
<li>在 Android P 和以后，无需做任何事情，Simpleperf 就可以支持 Java 代码分析。<blockquote>
<p>在 Android Studio 3.2 也在 Profiler 中直接支持 Simpleperf。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h4 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h4><p>选择哪种工具，需要看具体的场景。</p>
<ul>
<li>如果需要分析 Native 代码的耗时，可以选择 Simpleperf。</li>
<li>如果想分析系统调用，可以选择 systrace。</li>
<li>如果想分析整个程序执行流程的耗时，可以选择 Traceview 或者插桩版本的 systrace。</li>
</ul>
<h3 id="可视化方法"><a href="#可视化方法" class="headerlink" title="可视化方法"></a>可视化方法</h3><p>在 Android Studio 3.2 的 Profiler 中直接集成了几种性能分析工具：</p>
<ul>
<li>Sample Java Methods 的功能类似于 Traceview 的 sample 类型。</li>
<li>Trace Java Methods 的功能类似于 Traceview 的 instrument 类型。</li>
<li>Trace System Calls 的功能类似于 systrace。</li>
<li>SampleNative (API Level 26+) 的功能类似于 Simpleperf。</li>
</ul>
<p>对 Profiler 中这几种工具的评价：</p>
<ul>
<li>Profiler 大大降低了开发者的使用门槛。</li>
<li>Profiler 界面在某些方面不如这些工具自带的界面，支持配置的参数也不如命令行。</li>
</ul>
<p>这些分析工具都支持了 Call Chart 和 Flame Chart 两种展示方式：</p>
<ol>
<li><strong>Call Chart:</strong> Call Chart 是 Traceview 和 systrace 默认使用的展示方式。它按照应用程序的函数执行顺序来展示，适合用于分析整个流程的调用。<ul>
<li>Call Chart 就像给应用程序做一个心电图，我们可以看到在这一段时间内，各个线程的具体工作，比如是否存在线程间的锁、主线程是否存在长时间的 I/O 操作、是否存在空闲等。</li>
<li>举一个最简单的例子，A 函数调用 B 函数，B 函数调用 C 函数，循环三次，就得到了下面的 Call Chart。<br><img src="https://static001.geekbang.org/resource/image/db/3e/db3612f661d29efe59854df2e6c2383e.jpg" alt=""></li>
</ul>
</li>
<li><strong>Flame Chart:</strong> 即大名鼎鼎的火焰图。当我们不想知道应用程序的整个调用流程，只想直观看出哪些代码路径花费的 CPU 时间较多时，火焰图就是一个非常好的选择。它跟 Call Chart 不同的是，Flame Chart 以一个全局的视野来看待一段时间的调用分布。<ul>
<li>它就像给应用程序拍 X 光片，可以很自然地把时间和空间两个维度上的信息融合在一张图上。</li>
<li>上面函数调用的例子，换成火焰图的展示结果如下。<br><img src="https://static001.geekbang.org/resource/image/6c/01/6ca232173daf9e71f06ac22252d65d01.jpg" alt=""></li>
<li>火焰图还可以使用在各种各样的维度，例如内存、I/O 的分析。有些内存可能非常缓慢地泄漏，通过一个内存的火焰图，我们就知道哪些路径申请的内存最多，有了火焰图我们根本不需要分析源代码，也不需要分析整个流程。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="06-卡顿优化（下）：如何监控应用卡顿？"><a href="#06-卡顿优化（下）：如何监控应用卡顿？" class="headerlink" title="06 | 卡顿优化（下）：如何监控应用卡顿？"></a>06 | 卡顿优化（下）：如何监控应用卡顿？</h1><h3 id="卡顿监控"><a href="#卡顿监控" class="headerlink" title="卡顿监控"></a>卡顿监控</h3><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul>
<li><strong>方案1:</strong> 替换 Looper 的 Printer<br>  <img src="https://static001.geekbang.org/resource/image/10/b3/10a39c4253447b3e9d0a5045795d47b3.png" alt=""><ul>
<li><strong>缺点:</strong> 线上开启了这个监控模块，快速滑动时平均帧率起码降低 5 帧。因为上面图中所示的大量字符串拼接导致性能损耗严重。</li>
</ul>
</li>
<li><strong>方案2:</strong> 实现一个监控线程，每隔 1 秒向主线程消息队列的头部插入一条空消息。假设 1 秒后这个消息并没有被主线程消费掉，说明阻塞消息运行的时间在 0～1 秒之间。如果我们需要监控 3 秒卡顿，那在第 4 次轮询中头部消息依然没有被消费的话，就可以确定主线程出现了一次 3 秒以上的卡顿。<br>  <img src="https://static001.geekbang.org/resource/image/b0/56/b06d5aa439e8bb75885a338df9a25f56.png" alt=""><ul>
<li><strong>缺点:</strong> 这个方案也存在一定的误差，那就是发送空消息的间隔时间。但这个间隔时间也不能太小，因为监控线程和主线程处理空消息都会带来一些性能损耗，但基本影响不大。</li>
</ul>
</li>
<li><strong>消息队列方案的问题:</strong> 我们假设一个消息循环里面顺序执行了 A、B、C 三个函数，当整个消息执行超过 3 秒时，因为函数 A 和 B 已经执行完毕，我们只能得到的正在执行的函数 C 的堆栈，事实上它可能并不耗时。<br>  <img src="https://static001.geekbang.org/resource/image/8e/bf/8ee841e21f4a40f2835fe846be143dbf.png" alt=""><blockquote>
<p>对于线上大数据来说，因为函数 A 和 B 相对比较耗时，所以抓取到它们的概率会更大一些，通过后台聚合后捕获到函数 A 和 B 的卡顿日志会更多一些。</p>
</blockquote>
</li>
</ul>
<h4 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h4><ul>
<li><strong>方案1:</strong> 利用 Android Runtime 函数调用的回调事件，做一个自定义的 Traceview++。但是需要使用 Inline Hook 技术，实现类似 Nanoscope 先写内存的方案。<ul>
<li><strong>缺点:</strong> 兼容性差</li>
</ul>
</li>
<li><strong>方案2:</strong> 那如果在编译过程插桩，兼容性问题肯定是 OK 的。上一讲讲到 systrace 可以通过插桩自动生成 Trace Tag，我们一样也可以在函数入口和出口加入耗时监控的代码。<br>  <img src="https://static001.geekbang.org/resource/image/55/aa/5554d062dd45d6d927a08be4a39926aa.png" alt=""><ul>
<li><strong>该方案需要考虑的细节</strong><ul>
<li><strong>避免方法数暴增。</strong> 在函数的入口和出口应该插入相同的函数，在编译时提前给代码中每个方法分配一个独立的 ID 作为参数。</li>
<li><strong>过滤简单的函数。</strong> 过滤一些类似直接 return、i++ 这样的简单函数，并且支持黑名单配置。对一些调用非常频繁的函数，需要添加到黑名单中来降低整个方案对性能的损耗。</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>只能监控应用内自身的函数耗时，无法监控系统的函数调用，整个堆栈看起来好像“缺失了”一部分。</li>
<li>基于性能的考虑，线上只会监控主线程的耗时。<blockquote>
<p>微信的 Matrix 使用的就是这个方案，因为做了大量的优化，所以最终安装包体积只增大 1～2%，平均帧率下降也在 2 帧以内。虽然插桩方案对性能的影响总体还可以接受，但只会在灰度包使用。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Profilo"><a href="#Profilo" class="headerlink" title="Profilo"></a>Profilo</h4><p>Facebook 开源了一个叫 Profilo 的库，它收集了各大方案的优点。</p>
<ul>
<li><strong>集成 atrace 功能。</strong> ftrace 所有性能埋点数据都会通过 trace_marker 文件写入内核缓冲区，Profilo 通过 PLT Hook 拦截了写入操作，选择部分关心的事件做分析。这样所有 systrace 的探针我们都可以拿到，例如四大组件生命周期、锁等待时间、类校验、GC 时间等。<strong>不过大部分的 atrace 事件都比较笼统，从事件“B|pid|activityStart”，我们并不知道具体是哪个 Activity 的创建。同样我们可以统计 GC 相关事件的耗时，但是也不知道为什么发生了这次 GC。</strong><br>  <img src="https://static001.geekbang.org/resource/image/7f/fc/7f4abeb31fbc50546b0481435e7a7bfc.jpg" alt=""></li>
<li><strong>快速获取 Java 堆栈。</strong> 很多同学有一个误区，觉得在某个线程不断地获取主线程堆栈是不耗时的。但是事实上获取堆栈的代价是巨大的，它要暂停主线程的运行。<ul>
<li>Profilo 的实现非常精妙，它实现类似 Native 崩溃捕捉的方式快速获取 Java 堆栈，通过间隔发送 SIGPROF 信号，整个过程如下图所示。<br><img src="https://static001.geekbang.org/resource/image/2f/b7/2f00261346ba4c85c9ae522766cf05b7.jpg" alt=""><br>Signal Handler 捕获到信号后，拿取到当前正在执行的 Thread，通过 Thread 对象可以获取当前线程的 ManagedStack，ManagedStack 是一个单链表，它保存了当前的 ShadowFrame 或者 QuickFrame 栈指针，先依次遍历 ManagedStack 链表，然后遍历其内部的 ShadowFrame 或者 QuickFrame 还原一个可读的调用栈，从而 unwind 出当前的 Java 堆栈。通过这种方式，可以实现线程一边继续跑步，我们还可以帮它做检查，而且耗时基本忽略不计。</li>
</ul>
</li>
<li><strong>缺点:</strong> 由于它利用了大量的黑科技，兼容性是需要注意的问题。它内部实现有大量函数的 Hook，unwind 也需要强依赖 Android Runtime 实现。目前 Profilo 快速获取堆栈功能依然不支持 Android 8.0 和 Android 9.0。</li>
</ul>
<h3 id="其他监控"><a href="#其他监控" class="headerlink" title="其他监控"></a>其他监控</h3><h4 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h4><p>业界都使用 Choreographer 来监控应用的帧率。跟卡顿不同的是，我们应该只在界面存在绘制的时候才做统计。可以通过 addOnDrawListener 来监听界面的绘制行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().getViewTreeObserver().addOnDrawListener</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>冻帧</strong><ul>
<li>对于用户来说，感觉最明显的是连续丢帧情况，Android Vitals 将连续丢帧超过 700 毫秒定义为<strong>冻帧</strong>，也就是连续丢帧 42 帧以上。</li>
<li><strong>冻帧率</strong>就是计算发生冻帧时间在所有时间的占比。</li>
</ul>
</li>
<li><strong>冻帧时的信息收集</strong><ul>
<li>出现丢帧的时候，我们可以获取当前的页面信息、View 信息和操作路径上报后台，降低二次排查的难度。</li>
<li>如下图一样，我们还可以按照 Activity、Fragment 或者某个操作定义场景，通过细化不同场景的平均帧率和冻帧率，进一步细化问题排查的范围。<br><img src="https://static001.geekbang.org/resource/image/73/ba/73b185f989a20e868886d10c864c43ba.png" alt=""></li>
</ul>
</li>
</ul>
<h4 id="生命周期监控"><a href="#生命周期监控" class="headerlink" title="生命周期监控"></a>生命周期监控</h4><p>Activity、Service、Receiver 组件生命周期的耗时和调用次数也是我们重点关注的性能问题。例如 Activity 的 onCreate() 不应该超过 1 秒，不然会影响用户看到页面的时间。Service 和 Receiver 虽然是后台组件，不过它们生命周期也是占用主线程的，也是我们需要关注的问题。</p>
<ul>
<li>对于组件生命周期我们应该采用更严格地监控，可以全量上报。<br>  <img src="https://static001.geekbang.org/resource/image/d4/67/d4e8abcb054793168dff716c7956ae67.png" alt=""></li>
<li>除了四大组件的生命周期，我们还需要监控各个进程生命周期的启动次数和耗时。通过下面的数据，我们可以看出某些进程是否频繁地拉起。<br>  <img src="https://static001.geekbang.org/resource/image/53/0c/534e422d44eb4b08ebdac2181b87f70c.png" alt=""></li>
</ul>
<h4 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h4><p>对于 Java 线程，总的来说需要监控以下两点。</p>
<ul>
<li><strong>线程数量。</strong> 需要监控线程数量的多少，以及创建线程的方式。例如有没有使用我们特有的线程池，这块可以通过 got hook 线程的 nativeCreate() 函数。主要用于进行线程收敛，也就是减少线程数量。</li>
<li><strong>线程时间。</strong> 监控线程的用户时间 utime、系统时间 stime 和优先级。主要是看哪些线程 utime+stime 时间比较多，占用了过多的 CPU。可能有一些线程因为生命周期很短导致很难发现，这里我们需要结合线程创建监控。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>相较解决来说，更困难的是如何快速发现这些卡顿点，以及通过更多的辅助信息找到真正的卡顿原因。</strong> 导致卡顿的原因会有很多，比如函数非常耗时、I/O 非常慢、线程间的竞争或者锁等。其实很多时候卡顿问题并不难解决。</li>
<li><strong>卡顿优化的难点在于如何把本地分析工具移植到线上，以最少的性能代价获得更加丰富的卡顿信息。</strong> 当然某些卡顿问题可能是 I/O、存储或者网络引发的，后面会还有专门的内容来讲这些问题的优化方法。</li>
</ul>
<hr>
<h1 id="06补充篇-卡顿优化：卡顿现场与卡顿分析"><a href="#06补充篇-卡顿优化：卡顿现场与卡顿分析" class="headerlink" title="06补充篇 | 卡顿优化：卡顿现场与卡顿分析"></a>06补充篇 | 卡顿优化：卡顿现场与卡顿分析</h1><h3 id="卡顿现场"><a href="#卡顿现场" class="headerlink" title="卡顿现场"></a>卡顿现场</h3><p>我先来举一个线上曾经发现的卡顿例子，下面是它的具体耗时信息。<br><img src="https://static001.geekbang.org/resource/image/23/46/2398281c40faaa3620f48e1d23da9046.png" alt=""></p>
<h4 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h4><p>进一步分析 openNonAsset 相关源码的时候发现，AssetManager 内部有大量的 synchronized 锁。首先我怀疑还是锁的问题，接下来需要把卡顿时各个线程的状态以及堆栈收集起来做进一步分析。</p>
<ol>
<li><strong>获得 Java 线程状态。</strong> 通过 Thread 的 getState 方法可以获取线程状态。<ul>
<li>当时主线程是 BLOCKED 状态。</li>
<li><strong>WAITING、TIME_WAITING 和 BLOCKED 都是需要特别注意的状态。</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object)  &#123;     <span class="comment">// 情况一：在这里卡住 --&gt; BLOCKED</span></span><br><span class="line">    object.wait();           <span class="comment">// 情况二：在这里卡住 --&gt; WAITING</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>获得所有线程堆栈。</strong> 接着我们在 Java 层通过 Thread.getAllStackTraces() 进一步拿所有线程的堆栈，希望知道具体是因为哪个线程导致主线程的 BLOCKED。<ul>
<li>通过分析收集上来的卡顿日志，我们发现跟 AssetManager 相关的线程有下面这个。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;BackgroundHandler&quot;  RUNNABLE</span><br><span class="line">    at  android.content.res.AssetManager.list</span><br><span class="line">    at  com.sample.business.init.listZipFiles</span><br></pre></td></tr></table></figure></li>
<li>通过查看AssetManager.list的确发现是使用了同一个 synchronized 锁，而 list 函数需要遍历整个目录，耗时会比较久。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list(String path) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ensureValidLocked();</span><br><span class="line">        <span class="keyword">return</span> nativeList(mObject, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>另外一方面，“BackgroundHandler”线程属于低优先级后台线程，这也是我们前面文章提到的不良现象，也就是主线程等待低优先级的后台线程。</li>
</ul>
</li>
</ol>
<h4 id="SIGQUIT-信号实现-获取-ANR-日志"><a href="#SIGQUIT-信号实现-获取-ANR-日志" class="headerlink" title="SIGQUIT 信号实现 (获取 ANR 日志)"></a>SIGQUIT 信号实现 (获取 ANR 日志)</h4><ul>
<li><strong>ANR 日志的获取</strong><ol>
<li>当监控到主线程卡顿时，主动向系统发送 SIGQUIT 信号。</li>
<li>等待 /data/anr/traces.txt 文件生成。</li>
<li>文件生成以后进行上报。</li>
</ol>
</li>
<li><strong>通过 ANR 日志，我们可以直接看到主线程的锁是由“BackgroundHandler”线程持有。</strong> 相比之下通过 getAllStackTraces 方法，我们只能通过一个一个线程进行猜测。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 堆栈相关信息</span><br><span class="line">at android.content.res.AssetManager.open(AssetManager.java:311)</span><br><span class="line">- waiting to lock &lt;0x41ddc798&gt; (android.content.res.AssetManager) held by tid&#x3D;66 (BackgroundHandler)</span><br><span class="line">at android.content.res.AssetManager.open(AssetManager.java:289)</span><br></pre></td></tr></table></figure></li>
<li><strong>ANR 日志显示了 Native 参数，需要注意 Native 线程状态与 Java 线程状态的关系。</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程名称 ; 优先级 ; 线程 id; 线程状态</span><br><span class="line">&quot;main&quot; prio&#x3D;5 tid&#x3D;1 Suspended</span><br><span class="line">  &#x2F;&#x2F; 线程组 ;  线程 suspend 计数 ; 线程 debug suspend 计数 ; </span><br><span class="line">  | group&#x3D;&quot;main&quot; sCount&#x3D;1 dsCount&#x3D;0 obj&#x3D;0x74746000 self&#x3D;0xf4827400</span><br><span class="line">  &#x2F;&#x2F; 线程 native id; 进程优先级 ; 调度者优先级 ;</span><br><span class="line">  | sysTid&#x3D;28661 nice&#x3D;-4 cgrp&#x3D;default sched&#x3D;0&#x2F;0 handle&#x3D;0xf72cbbec</span><br><span class="line">  &#x2F;&#x2F; native 线程状态 ; 调度者状态 ; 用户时间 utime; 系统时间 stime; 调度的 CPU</span><br><span class="line">  | state&#x3D;D schedstat&#x3D;( 3137222937 94427228 5819 ) utm&#x3D;218 stm&#x3D;95 core&#x3D;2 HZ&#x3D;100</span><br><span class="line">  &#x2F;&#x2F; stack 相关信息</span><br><span class="line">  | stack&#x3D;0xff717000-0xff719000 stackSize&#x3D;8MB</span><br></pre></td></tr></table></figure>
<ul>
<li>在 Android 里面 Java 线程的运行都委托于一个 Linux 标准线程 pthread 来运行，而 Android 里运行的线程可以分成两种：<ul>
<li>Attach 到虚拟机的</li>
<li>没有 Attach 到虚拟机的</li>
</ul>
</li>
<li>在虚拟机管理的线程都是托管的线程，所以<strong>本质上 Java 线程的状态其实是 Native 线程的一种映射。</strong> 如上面 ANR 日志所示的 Suspended 代表的是 Native 线程状态。</li>
</ul>
</li>
<li>不同的 Android 版本 Native 线程的状态不太一样，例如 Android 9.0 就定义了 27 种线程状态，它能更加明确地区分线程当前所处的情况。<br>  <img src="https://static001.geekbang.org/resource/image/af/4b/af6485856d47626b13433f96ec48d44b.png" alt=""><ul>
<li>Native 线程状态更加丰富，例如将 TIMED_WAITING 拆分成 TimedWaiting 和 Sleeping 两种场景，而 WAITING 更是细化到十几种场景等，这对我们分析特定场景问题的时候会有非常大的帮助。</li>
</ul>
</li>
</ul>
<h4 id="Hook-实现"><a href="#Hook-实现" class="headerlink" title="Hook 实现"></a>Hook 实现</h4><ul>
<li><strong>用 SIGQUIT 信号量获取 ANR 日志的问题：</strong><ul>
<li><strong>可行性。</strong> 很多高版本系统已经没有权限读取 /data/anr/traces.txt 文件。</li>
<li><strong>性能。</strong> 获取所有线程堆栈以及各种信息非常耗时，对于卡顿场景不一定合适，它可能会进一步加剧用户的卡顿。</li>
</ul>
</li>
<li><strong>通过 Hook 获取 ANR 日志</strong><ul>
<li><strong>流程</strong><ol>
<li>通过 libart.so、dlsym 调用 ThreadList::ForEach 方法，拿到所有的 Native 线程对象。</li>
<li>遍历线程对象列表，调用 Thread::DumpState 方法。</li>
</ol>
</li>
<li><strong>崩溃问题:</strong> 它基本模拟了系统打印 ANR 日志的流程，但是因为整个过程使用了一些黑科技，可能会造成线上崩溃。</li>
<li><strong>崩溃问题的解决方案:</strong> 为了兼容性考虑，我们会通过 fork 子进程方式实现，这样即使子进程崩溃了也不会影响我们主进程的运行。<ul>
<li>这样还可以带来另外一个非常大的好处，获取所有线程堆栈这个过程可以做到完全不卡我们主进程。</li>
<li>使用 fork 进程会导致进程号改变，源码中通过 /proc/self 方式获取的一些信息都会失败（错误的拿了子进程的信息，而子进程只有一个线程），例如 state、schedstat、utm、stm、core 等。不过问题也不大，这些信息可以通过指定 /proc/[父进程 id] 的方式重新获取。</li>
</ul>
</li>
<li><strong>总结:</strong> 通过 Hook 方式实现了一套“无损”获取所有 Java 线程堆栈与详细信息的方法。为了降低上报数据量，只有主线程的 Java 线程状态是 WAITING、TIME_WAITING 或者 BLOCKED 的时候，才会进一步使用这种方案。</li>
</ul>
</li>
</ul>
<h4 id="其他卡顿现场信息"><a href="#其他卡顿现场信息" class="headerlink" title="其他卡顿现场信息"></a>其他卡顿现场信息</h4><ul>
<li><strong>CPU 使用率和调度信息。</strong> 例如系统 CPU 使用率、负载、各线程的 CPU 使用率以及 I/O 调度等信息。</li>
<li><strong>内存相关信息。</strong> 例如系统总内存、可用内存以及应用各个进程的内存等信息。如果开启了 Debug.startAllocCounting 或者 atrace，还可以增加 GC 相关的信息。</li>
<li><strong>I/O 和网络相关。</strong> 可以把卡顿期间所有的 I/O 和网络操作的详细信息也一并收集。</li>
<li><strong>最后我们还可以利用崩溃分析中的一些思路。</strong> 例如添加用户操作路径等信息，这样我们可以得到一份比系统 ANR 更加丰富的卡顿日志，这对我们解决某些疑难的卡顿问题会更有帮助。</li>
</ul>
<h3 id="卡顿分析"><a href="#卡顿分析" class="headerlink" title="卡顿分析"></a>卡顿分析</h3><h4 id="卡顿率"><a href="#卡顿率" class="headerlink" title="卡顿率"></a>卡顿率</h4><ul>
<li><strong>UV 卡顿率:</strong> 如果把主线程卡顿超过 3 秒定义为一个卡顿问题，类似崩溃，我们会先评估卡顿问题的影响面，也就是 UV 卡顿率。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UV 卡顿率 &#x3D; 发生过卡顿 UV &#x2F; 开启卡顿采集 UV</span><br></pre></td></tr></table></figure>
<ul>
<li>因为卡顿问题一般都是抽样上报，采样规则跟内存相似，都应该按照人来抽样。一个用户如果命中采集，那么在一天内都会持续的采集数据。</li>
<li>UV 卡顿率可以评估卡顿的影响范围。</li>
</ul>
</li>
<li><strong>PV 卡顿率:</strong> UV 卡顿率对于低端机器来说比较难去优化卡顿的问题，如果想评估卡顿的严重程度，我们可以使用 PV 卡顿率。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PV 卡顿率 &#x3D; 发生过卡顿 PV &#x2F; 启动采集 PV</span><br></pre></td></tr></table></figure>
<ul>
<li>需要注意的是，对于命中采集 PV 卡顿率的用户，每次启动都需要上报作为分母。</li>
</ul>
</li>
</ul>
<h4 id="卡顿树"><a href="#卡顿树" class="headerlink" title="卡顿树"></a>卡顿树</h4><p>发生卡顿时，我们会把 CPU 使用率和负载相关信息也添加到卡顿日志中。虽然采取了抽样策略，但每天的日志量还是达到十万级别。这么大的日志量，<strong>如果简单采用堆栈聚合日志，会发现有几百上千种卡顿类型，很难看出重点。</strong></p>
<p>这里推荐<strong>卡顿树</strong>的做法，对于超过 3 秒的卡顿，具体是 4 秒还是 10 秒，这涉及手机性能和当时的环境。<strong>我们抛弃具体的耗时，只按照相同堆栈出现的比例来聚合。</strong> 这样我们 <strong>从一棵树上面，就可以看到哪些堆栈出现的卡顿问题最多，它下面又存在的哪些分支。</strong><br><img src="https://static001.geekbang.org/resource/image/ca/5d/ca54f510455317ce487476cbe9cd285d.png" alt=""></p>
<hr>
<h1 id="07-启动优化（上）：从启动过程看启动速度优化"><a href="#07-启动优化（上）：从启动过程看启动速度优化" class="headerlink" title="07 | 启动优化（上）：从启动过程看启动速度优化"></a>07 | 启动优化（上）：从启动过程看启动速度优化</h1><h3 id="启动分析"><a href="#启动分析" class="headerlink" title="启动分析"></a>启动分析</h3><h4 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h4><p>这里以微信为例，用户从桌面点击图标开始，会经过 4 个关键阶段。<br><img src="https://static001.geekbang.org/resource/image/0d/43/0da2051f1f8d182a531063eb202abf43.png" alt=""></p>
<ol>
<li><strong>T1 预览窗口显示。</strong> 系统在拉起微信进程之前，会先根据微信的 Theme 属性创建预览窗口。当然如果我们禁用预览窗口或者将预览窗口指定为透明，用户在这段时间依然看到的是桌面。</li>
<li><strong>T2 闪屏显示。</strong> 在微信进程和闪屏窗口页面创建完毕，并且完成一系列 inflate view、onmeasure、onlayout 等准备工作后，用户终于可以看到熟悉的“小地球”。</li>
<li><strong>T3 主页显示。</strong> 在完成主窗口创建和页面显示的准备工作后，用户可以看到微信的主界面。</li>
<li><strong>T4 界面可操作。</strong> 在启动完成后，微信会有比较多的工作需要继续执行，例如聊天和朋友圈界面的预加载、小程序框架和进程的准备等。在这些工作完成后，用户才可以真正开始愉快地聊天。</li>
</ol>
<h4 id="启动问题分析"><a href="#启动问题分析" class="headerlink" title="启动问题分析"></a>启动问题分析</h4><p>从启动流程的 4 个关键阶段，我们可以推测出用户启动过程会遇到的 3 个问题。</p>
<ul>
<li><strong>点击图标很久都不响应。</strong> 如果我们禁用了预览窗口或者指定了透明的皮肤，那用户点击了图标之后，需要 T2 时间才能真正看到应用闪屏。对于用户体验来说，点击了图标，过了几秒还是停留在桌面，看起来就像没有点击成功，这在中低端机中更加明显。</li>
<li><strong>首页显示太慢。</strong> 现在应用启动流程越来越复杂，闪屏广告、热修复框架、插件化框架、大前端框架，所有准备工作都需要集中在启动阶段完成。上面说的 T3 首页显示时间对于中低端机来说简直就是噩梦，经常会达到十几秒的时间。</li>
<li><strong>首页显示后无法操作。</strong> 既然首页显示那么慢，那我能不能把尽量多的工作都通过异步化延后执行呢？很多应用的确就是这么做的，但这会造成两种后果：要么首页会出现白屏，要么首页出来后用户根本无法操作。</li>
</ul>
<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><h4 id="优化工具"><a href="#优化工具" class="headerlink" title="优化工具"></a>优化工具</h4><p><strong>只有准确的数据评估才能指引优化的方向，这一步是非常非常重要的。</strong> “systrace + 函数插桩” 是比较理想的方案，性能损耗在一倍以内，基本可以反映真实的启动流程。而且它还可以看到系统的一些关键事件，例如 GC、System Server、CPU 调度等。</p>
<ul>
<li>我们可以通过下面的命令，可以查看手机支持哪些 systrace 类型。不同的系统支持的类型有所差别，其中 Dalvik、sched、ss、app 都是我们比较关心的。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py --list-categories</span><br></pre></td></tr></table></figure></li>
<li>通过插桩，我们可以看到应用主线程和其他线程的函数调用流程。它的实现原理非常简单，就是将下面的两个函数分别插入到每个方法的入口和出口。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Trace &#123;</span><br><span class="line">public static void i(String tag) &#123;</span><br><span class="line">    Trace.beginSection(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void o() &#123;</span><br><span class="line">    Trace.endSection();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h4><ol>
<li><strong>闪屏优化</strong><ul>
<li>可以把预览窗口实现成闪屏的效果，这样用户只需要很短的时间就可以看到“预览闪屏”。<ul>
<li>这种完全“跟手”的感觉在高端机上体验非常好，但对于中低端机，会把总的的闪屏时间变得更长。</li>
<li>比较推荐的做法是，只在 Android 6.0 或者 Android 7.0 以上才启用“预览闪屏”方案，让手机性能好的用户可以有更好的体验。</li>
</ul>
</li>
<li>合并闪屏和主页面的 Activity，减少一个 Activity 会给线上带来 100 毫秒左右的优化。<ul>
<li>但是如果这样做的话，管理时会非常复杂，特别是有很多例如 PWA、扫一扫这样的第三方启动流程的时候。</li>
</ul>
</li>
</ul>
</li>
<li><strong>业务梳理</strong><ul>
<li>梳理清楚当前启动过程正在运行的每一个模块，哪些是一定需要的、哪些可以砍掉、哪些可以懒加载。</li>
<li>根据业务场景来决定不同的启动模式，例如通过扫一扫启动只需要加载需要的几个模块即可。</li>
<li>对于中低端机器，我们要学会降级，学会推动产品经理做一些功能取舍。</li>
<li>懒加载要防止集中化，否则容易出现首页显示后用户无法操作的情形。</li>
</ul>
</li>
<li><strong>业务优化:</strong> 通过梳理之后，剩下的都是启动过程一定要用的模块。<ul>
<li>优化前期需要“抓大放小”，先看看主线程究竟慢在哪里。</li>
<li>业务优化方式<ul>
<li>最理想是通过算法进行优化，例如一个数据解密操作需要 1 秒，通过算法优化之后变成 10 毫秒。</li>
<li>退而求其次，我们要考虑这些任务是不是可以通过异步线程预加载实现，但需要注意的是过多的线程预加载会让我们的逻辑变得更加复杂。</li>
</ul>
</li>
<li>业务优化做到后面，会发现一些架构和历史包袱会拖累我们前进的步伐。<ul>
<li>比较常见的是一些事件会被各个业务模块监听，大量的回调导致很多工作集中执行，部分框架初始化“太厚”，例如一些插件化框架，启动过程各种反射、各种 Hook，整个耗时至少几百毫秒。</li>
<li>还有一些历史包袱又非常沉重，而且“牵一发动全身”，改动风险比较大。如果有合适的时机，我们依然需要勇敢去偿还这些“历史债务”。</li>
</ul>
</li>
</ul>
</li>
<li><strong>线程优化:</strong> 线程的优化主要在于减少 CPU 调度带来的波动，让应用的启动时间更加稳定。<ul>
<li><strong>控制线程数量。</strong> 线程数量太多会相互竞争 CPU 资源，因此要有统一的线程池，并且根据机器性能来控制数量。线程切换的数据我们可以通过卡顿优化中学到的 sched 文件查看，这里特别需要注意 nr_involuntary_switches 被动切换的次数。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proc&#x2F;[pid]&#x2F;sched:</span><br><span class="line">    nr_voluntary_switches：     </span><br><span class="line">    主动上下文切换次数，因为线程无法获取所需资源导致上下文切换，最普遍的是 IO。    </span><br><span class="line">    nr_involuntary_switches：   </span><br><span class="line">    被动上下文切换次数，线程被系统强制调度导致上下文切换，例如大量线程在抢占 CPU。</span><br></pre></td></tr></table></figure></li>
<li><strong>检查线程间的锁。</strong> 通过 systrace 可以看到锁等待的事件，我们需要排查这些等待是否可以优化，特别是防止主线程出现长时间的空转。<br>  <img src="https://static001.geekbang.org/resource/image/36/b2/36316813548502f6cf241189e2a73cb2.png" alt=""></li>
<li><strong>使用启动框架实现 Pipeline 机制，根据业务优先级规定业务初始化时机。</strong> 比如微信内部使用的 mmkernel、阿里最近开源的 Alpha 启动框架，它们为各个任务建立依赖关系，最终构成一个有向无环图。对于可以并发的任务，会通过线程池最大程度提升启动速度。如果任务的依赖关系没有配置好，很容易出现下图这种情况，即主线程会一直等待 taskC 结束，空转 2950 毫秒。<br>  <img src="https://static001.geekbang.org/resource/image/86/db/868a5f4c47224be920e97b82d03905db.png" alt=""></li>
</ul>
</li>
<li><strong>GC 优化</strong><ul>
<li>在启动过程，要尽量减少 GC 的次数，避免造成主线程长时间的卡顿。<ul>
<li>对 Dalvik 来说，我们可以通过 systrace 单独查看整个启动过程 GC 的时间。  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py dalvik -b 90960 -a com.sample.gc</span><br></pre></td></tr></table></figure></li>
<li>我们也可以使用  Debug.startAllocCounting 来监控启动过程总 GC 的耗时情况，特别是阻塞式同步 GC 的总次数和耗时。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GC 使用的总耗时，单位是毫秒</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.gc-time"</span>);</span><br><span class="line"><span class="comment">// 阻塞式 GC 的总耗时</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.blocking-gc-time"</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果我们发现主线程出现比较多的 GC 同步等待，那就需要通过 Allocation 工具做进一步的分析。</li>
<li>启动过程避免进行大量的字符串操作，特别是序列化跟反序列化过程。一些频繁创建的对象，例如网络库和图片库中的 Byte 数组、Buffer 可以复用。如果一些模块实在需要频繁创建对象，可以考虑移到 Native 实现。</li>
<li>Java 对象的逃逸也很容易引起 GC 问题，我们在写代码的时候比较容易忽略这个点。我们应该保证对象生命周期尽量的短，在栈上就进行销毁。</li>
</ul>
</li>
<li><strong>系统调用优化:</strong> 通过 systrace 的 System Service 类型，我们可以看到启动过程 System Server 的 CPU 工作情况。<ul>
<li><strong>尽量不要做系统调用。</strong> 例如 PackageManagerService 操作、Binder 调用等待。</li>
<li><strong>不要过早地拉起应用的其他进程。</strong> System Server 和新的进程都会竞争 CPU 资源。特别是系统内存不足的时候，当我们拉起一个新的进程，可能会成为“压死骆驼的最后一根稻草”。它可能会触发系统的 low memory killer 机制，导致系统杀死和拉起（保活）大量的进程，从而影响前台进程的 CPU。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="08-启动优化（下）：优化启动速度的进阶方法"><a href="#08-启动优化（下）：优化启动速度的进阶方法" class="headerlink" title="08 | 启动优化（下）：优化启动速度的进阶方法"></a>08 | 启动优化（下）：优化启动速度的进阶方法</h1><h3 id="启动进阶方法"><a href="#启动进阶方法" class="headerlink" title="启动进阶方法"></a>启动进阶方法</h3><h4 id="I-O-优化"><a href="#I-O-优化" class="headerlink" title="I/O 优化"></a>I/O 优化</h4><p>在负载过高的时候，I/O 性能下降得会比较快。特别是对于低端机，同样的 I/O 操作耗时可能是高端机器的几十倍。</p>
<ul>
<li>启动过程不建议出现网络 I/O，相比之下，磁盘 I/O 是启动优化一定要抠的点。</li>
<li>I/O 性能监控包括读了什么文件、多少个字节、Buffer 是多大、使用了多长时间、在什么线程等一系列信息。<br>  <img src="https://static001.geekbang.org/resource/image/b9/d7/b901216f4231f43475ca1227f25b6ed7.png" alt=""></li>
<li>重度用户是启动优化一定要覆盖的群体，我们要做一些特殊的优化策略。<ul>
<li>我们经常发现本地启动明明非常快，为什么线上有些用户就那么慢？这可能是一些用户本地积累了非常多的数据。如上图所示，有些重度用户 chat.db 的大小达到了 500M。</li>
</ul>
</li>
<li>数据结构的选择<ul>
<li>启动过程适合使用随机读写的数据结构，以加快速度。<ul>
<li>可以将 ArrayMap 改造成支持随机读写、延时解析的数据存储方式。</li>
</ul>
</li>
<li>启动时可以按需减少不必要的 I/O 操作。<ul>
<li>我们在启动过程只需要读取 Setting.sp 的几项数据，不过 SharedPreference 在初始化的时候还是要全部数据一起解析。如果它的数据量超过 1000 条，启动过程解析时间可能就超过 100 毫秒。如果只解析启动过程用到的数据项则会很大程度减少解析时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据重排"><a href="#数据重排" class="headerlink" title="数据重排"></a>数据重排</h4><p>Linux 文件系统从磁盘读文件的时候，会以 block 为单位去磁盘读取，一般 block 大小是 4KB。也就是说一次磁盘读写大小至少是 4KB，然后会把 4KB 数据放到页缓存 Page Cache 中。如果下次读取文件数据已经在页缓存中，那就不会发生真实的磁盘 I/O，而是直接从页缓存中读取，大大提升了读的速度。</p>
<p>Dex 文件用的到的类和安装包 APK 里面各种资源文件一般都比较小，但是读取非常频繁。我们可以利用系统这个机制将它们按照读取顺序重新排列，减少真实的磁盘 I/O 次数。</p>
<ul>
<li><p><strong>类重排</strong></p>
<ol>
<li>启动过程类加载顺序可以通过复写 ClassLoader 得到。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetClassLoader</span> <span class="keyword">extends</span> <span class="title">PathClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        <span class="comment">// 将 name 记录到文件</span></span><br><span class="line">        writeToFile(name，<span class="string">"coldstart_classes.txt"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后通过 ReDex 的 Interdex 调整类在 Dex 中的排列顺序，最后可以利用 010 Editor 查看修改后的效果。<br><img src="https://static001.geekbang.org/resource/image/5f/04/5f118a4064ada2fc6b978f4025d57404.png" alt=""><blockquote>
<p><a href="https://github.com/facebook/redex" target="_blank" rel="noopener">ReDex</a>，是 Facebook 开源的 Dex 优化工具</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>资源文件重排</strong></p>
<ul>
<li>通过修改 Kernel 源码，单独编译一个特殊的 ROM。这样做的目的有三个：<ul>
<li><strong>统计。</strong> 统计应用启动过程加载了安装包中哪些资源文件，比如 assets、drawable、layout 等。跟类重排一样，我们可以得到一个资源加载的顺序列表。</li>
<li><strong>度量。</strong> 在完成资源顺序重排后，我们需要确定是否真正生效。比如有哪些资源文件加载了，它是发生真实的磁盘 I/O，还是命中了 Page Cache。</li>
<li><strong>自动化。</strong> 任何代码提交都有可能改变启动过程中类和资源的加载顺序，如果完全依靠人工手动处理，这个事情很难持续下去。通过定制 ROM 的一些埋点和配合的工具，我们可以将它们放到自动化流程当中。<blockquote>
<p>Facebook “资源热图” 相对比较完善，也建设了一些配套的 Dashboard 工具，希望后续可以开源出来。</p>
</blockquote>
</li>
</ul>
</li>
<li>如果仅仅为了统计，我们也可以使用 Hook 的方式。<ol>
<li>下面是利用 Frida 实现获得 Android 资源加载顺序的方法。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resourceImpl.loadXmlResourceParser.implementation=function(a,b,c,d)&#123;</span><br><span class="line">send(<span class="string">'file:'</span>+a)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.loadXmlResourceParser(a,b,c,d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resourceImpl.loadDrawableForCookie.implementation=function(a,b,c,d,e)&#123;</span><br><span class="line">send(<span class="string">"file:"</span>+a)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.loadDrawableForCookie(a,b,c,d,e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>调整安装包文件排列需要修改 7zip 源码实现支持传入文件列表顺序，同样最后可以利用 010 Editor 查看修改后的效果。<br> <img src="https://static001.geekbang.org/resource/image/ea/b1/eaef116a5c0d6be1f3687b159fd214b1.png" alt=""></li>
</ol>
</li>
</ul>
</li>
</ul>
<p>类重排与资源重排可能会带来 100～200 毫秒的提高，<strong>还大大减少启动过程 I/O 的时间波动。</strong> 特别是对于中低端机器来说，经常发现启动时间波动非常大，这个波动跟 CPU 调度相关，但更多时候是跟 I/O 相关。</p>
<h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><p>在加载类的过程有一个 verify class 的步骤，它需要校验方法的每一个指令，是一个比较耗时的操作。<br><img src="https://static001.geekbang.org/resource/image/d2/d2/d2dbf21396e16c0cd53bbc3c0be405d2.png" alt=""></p>
<p>我们可以通过 Hook 来去掉 verify 这个步骤，这对启动速度有几十毫秒的优化。其实最大的优化场景在于首次和覆盖安装时。</p>
<ul>
<li>以 Dalvik 平台为例，一个 2MB 的 Dex 正常需要 350 毫秒，将 classVerifyMode 设为 VERIFY_MODE_NONE 后，只需要 150 毫秒，节省超过 50% 的时间。</li>
<li>ART 平台要复杂很多，Hook 需要兼容几个版本。而且在安装时大部分 Dex 已经优化好了，去掉 ART 平台的 verify 只会对动态加载的 Dex 带来一些好处。</li>
</ul>
<p>这个黑科技可以大大降低首次启动的速度，代价是对后续运行会产生轻微的影响。同时也要考虑兼容性问题，暂时不建议在 ART 平台使用。</p>
<h4 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h4><ul>
<li><strong>保活:</strong> 保活可以减少 Application 创建跟初始化的时间，让冷启动变成温启动。不过在 Target 26 之后，保活的确变得越来越难。<ul>
<li>例如微信的 Hardcoder 方案和 OPPO 推出的Hyper Boost方案。根据 OPPO 的数据，对于手机 QQ、淘宝、微信启动场景会直接有 20% 以上的优化。</li>
<li>这里可能不仅仅是技术上的问题，当应用体量足够大，就可以倒逼厂商去专门为它们做优化。</li>
</ul>
</li>
<li><strong>插件化和热修复:</strong> 事实上大部分的框架在设计上都存在大量的 Hook 和私有 API 调用，带来的缺点主要有两个：<ul>
<li><strong>稳定性。</strong> 虽然大家都号称兼容 100% 的机型，由于厂商的兼容性、安装失败、dex2oat 失败等原因，还是会有那么一些代码和资源的异常。<ul>
<li>Android P 推出的 non-sdk-interface 调用限制，以后适配只会越来越难，成本越来越高。</li>
</ul>
</li>
<li><strong>性能。</strong> Android Runtime 每个版本都有很多的优化，因为插件化和热修复用到的一些黑科技，导致底层 Runtime 的优化我们是享受不到的。<ul>
<li>Tinker 框架在加载补丁后，应用启动速度会降低 5%～10%。</li>
</ul>
</li>
</ul>
</li>
<li><strong>应用加固:</strong> 应用加固对启动速度来说简直是灾难，有时候我们需要做一些权衡和选择。<ul>
<li>为了提升启动速度，支付宝也提出一种GC 抑制的方案。不过首先 Android 5.0 以下的系统占比已经不高，其次这也会带来一些兼容性问题。我们还是更希望通过手段可以真正优化整个耗时，而不是一些取巧的方式。</li>
</ul>
</li>
</ul>
<p>总的来说，对于黑科技我们需要慎重，当你足够了解它们内部的机制以后，可以选择性的使用。</p>
<h3 id="启动监控"><a href="#启动监控" class="headerlink" title="启动监控"></a>启动监控</h3><h4 id="实验室监控"><a href="#实验室监控" class="headerlink" title="实验室监控"></a>实验室监控</h4><p>如果想客观地反映启动的耗时，视频录制会是一个非常好的选择。它的难点在于如何让实验系统准确地找到启动结束的点，这里可以通过下面两种方式。</p>
<ul>
<li><strong>80% 绘制。</strong> 当页面绘制超过 80% 的时候认为是启动完成，不过可能会把闪屏当成启动结束的点，不一定是我们所期望的。</li>
<li><strong>图像识别。</strong> 手动输入一张启动结束的图片，当实验系统认为当前截屏页面有 80% 以上相似度时，就认为是启动结束。这种方法更加灵活可控，但是实现难度会稍微高一点。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/ac/fd/acbbb4f9b147d68bfe9ab519642616fd.png" alt=""></p>
<p>启动的实验室监控可以定期自动去跑，但需要注意的是：</p>
<ul>
<li>我们应该覆盖高、中、低端机不同的场景。</li>
<li>使用录屏的方式也有一个缺陷，就是出现问题时我们需要人工二次定位具体是什么代码所导致的。</li>
</ul>
<h4 id="线上监控"><a href="#线上监控" class="headerlink" title="线上监控"></a>线上监控</h4><p>准确的启动耗时统计是非常重要的。有很多优化在实验室完成之后，还需要在线上灰度验证效果。这个前提是启动统计是准确的，整个效果评估是真实的。</p>
<p>启动耗时的计算需要考虑非常多的细节，比如：</p>
<ul>
<li><strong>启动结束的统计时机。</strong> 是否是使用用户真正可以操作的时间作为启动结束的时间。</li>
<li><strong>启动时间扣除的逻辑。</strong> 闪屏、广告和新手引导这些时间都应该从启动时间里扣除。</li>
<li><strong>启动排除逻辑。</strong> Broadcast、Server 拉起，启动过程进入后台这些都需要排除出统计。</li>
</ul>
<p>很多应用采用平均启动时间，不过这个指标其实并不太好，一些体验很差的用户很有可能是被平均了。我更建议使用类似下面的指标：</p>
<ul>
<li><strong>快开慢开比。</strong> 例如 2 秒快开比、5 秒慢开比，我们可以看到有多少比例的用户体验非常好，多少比例的用户比较槽糕。</li>
<li><strong>90% 用户的启动时间。</strong> 如果 90% 的用户启动时间都小于 5 秒，那么我们 90% 区间启动耗时就是 5 秒。</li>
</ul>
<p>此外我们还要区分启动的类型。这里要统计首次安装启动、覆盖安装启动、冷启动和温启动这些类型。</p>
<ul>
<li>一般我们都使用普通的冷启动时间作为指标。</li>
<li>另一方面热启动的占比也可以反映出我们程序的活跃或保活能力。</li>
</ul>
<hr>
<h1 id="09-I-O优化（上）：开发工程师必备的I-O优化知识"><a href="#09-I-O优化（上）：开发工程师必备的I-O优化知识" class="headerlink" title="09 | I/O优化（上）：开发工程师必备的I/O优化知识"></a>09 | I/O优化（上）：开发工程师必备的I/O优化知识</h1><h3 id="I-O-的基本知识"><a href="#I-O-的基本知识" class="headerlink" title="I/O 的基本知识"></a>I/O 的基本知识</h3><p><img src="https://static001.geekbang.org/resource/image/60/d4/60928bc51c0d04b1c39b24282e8126d4.jpg" alt=""></p>
<p>整个文件 I/O 操作由应用程序、文件系统和磁盘共同完成。首先应用程序将 I/O 命令发送给文件系统，然后文件系统会在合适的时机把 I/O 操作发给磁盘。这就好比 CPU、内存、磁盘三个小伙伴一起完成接力跑，<strong>最终跑完的时间很大程度上取决于最慢的小伙伴。</strong></p>
<p>CPU 和内存相比磁盘是高速设备，整个流程的瓶颈在于磁盘 I/O 的性能。<strong>所以很多时候，文件系统性能比磁盘性能更加重要，文件系统需要通过各种各样的手段进行优化，以优化其对磁盘的调用。</strong></p>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p><strong>文件系统，简单来说就是存储和组织数据的方式。</strong> 比如在 iOS 10.3 系统以后，苹果使用 APFS（Apple File System）替代之前旧的文件系统 HFS+。对于 Android 来说，现在普遍使用的是 Linux 常用的 ext4 文件系统。随着 Google、华为的投入和规模化使用，<strong>F2FS 系统应该是未来 Android 的主流文件系统。</strong></p>
<p>下面是 Linux 一个通用的 I/O 架构模型。<br><img src="https://static001.geekbang.org/resource/image/fb/4b/fb11cbe604eb6c0fc2ba5825275f104b.png" alt=""></p>
<ol>
<li>应用程序调用 read() 方法，系统会通过中断从用户空间进入内核处理流程</li>
<li><strong>进入 VFS（Virtual File System，虚拟文件系统）:</strong> 它主要用于实现屏蔽具体的文件系统，为应用程序的操作提供一个统一的接口。这样保证就算厂商把文件系统从 ext4 切换到 F2FS，应用程序也不用做任何修改。</li>
<li><strong>进入具体文件系统:</strong> ext4、F2FS 都是具体文件系统实现。文件元数据如何组织、目录和索引结构如何设计、怎么分配和清理数据，这些都是设计一个文件系统必须要考虑的。<ul>
<li><strong>每个文件系统都有适合自己的应用场景，我们不能说 F2FS 就一定比 ext4 要好。</strong> F2FS 在连续读取大文件上并没有优势，而且会占用更大的空间。只是对一般应用程序来说，随机 I/O 会更加频繁，特别是在启动的场景。</li>
<li>可以在 /proc/filesystems 看到系统可以识别的所有文件系统的列表。</li>
</ul>
</li>
<li><strong>进入页缓存 Page Cache:</strong> 在读文件的时候会，先看它是不是已经在 Page Cache 中，如果命中就不会去读取磁盘。<ul>
<li>Page Cache 就像是我们经常使用的数据缓存，是文件系统对数据的缓存，目的是提升内存命中率。需要注意的是，它们既会用在读请求中，也会用到写请求中。</li>
<li>通过 /proc/meminfo 文件可以查看缓存的内存占用情况，当手机内存不足的时候，系统会回收它们的内存，这样整体 I/O 的性能就会有所降低。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MemTotal:    2866492 kB</span><br><span class="line">MemFree:      72192 kB</span><br><span class="line">Buffers:      62708 kB      &#x2F;&#x2F; Buffer Cache</span><br><span class="line">Cached:      652904 kB      &#x2F;&#x2F; Page Cache</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p><img src="https://static001.geekbang.org/resource/image/13/18/13c06810c88632db1050ab3e56139a18.png" alt=""></p>
<ol>
<li><strong>通用块层。</strong> 通用块层主要作用是接收上层发出的磁盘请求，并最终发出 I/O 请求。它跟 VFS 的作用类似，让上层不需要关心底层硬件设备的具体实现。</li>
<li><strong>I/O 调度层。</strong> 磁盘 I/O 那么慢，为了降低真正的磁盘 I/O，我们不能接收到磁盘请求就立刻交给驱动层处理。所以我们增加了 I/O 调度层，它会根据设置的调度算法对请求合并和排序。这里比较关键的参数有两个：<ul>
<li>队列长度，可以通过下面的文件查看  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sys&#x2F;block&#x2F;[disk]&#x2F;queue&#x2F;nr_requests      &#x2F;&#x2F; 队列长度，一般是 128。</span><br></pre></td></tr></table></figure></li>
<li>具体的调度算法。可以通过下面的文件查看  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sys&#x2F;block&#x2F;[disk]&#x2F;queue&#x2F;scheduler        &#x2F;&#x2F; 调度算法</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>块设备驱动层。</strong> 系统中能够随机访问固定大小数据块（block）的设备称为块设备，CD、硬盘和 SSD 这些都属于块设备。块设备驱动层根据具体的物理设备，选择对应的驱动程序通过操控硬件设备完成最终的 I/O 请求。例如光盘是靠激光在表面烧录存储、闪存是靠电子擦写存储数据。</li>
</ol>
<h3 id="Android-I-O"><a href="#Android-I-O" class="headerlink" title="Android I/O"></a>Android I/O</h3><h4 id="Android-闪存"><a href="#Android-闪存" class="headerlink" title="Android 闪存"></a>Android 闪存</h4><p>手机使用闪存作为存储设备，也就是我们常说的 ROM。</p>
<ul>
<li>Android 手机前几年通常使用 eMMC 标准，近年来通常会采用性能更好的 UFS 2.0/2.1 标准。</li>
<li>最近几年移动端闪存朝着体积更小、功耗更低、速度更快、容量更大的方向狂奔。iPhone XS 的容量已经达到 512GB，连续读取速度可以超过 1GB/s，已经比很多的 SSD 固态硬盘还要快，同时也大大缩小了和内存的速度差距。不过这些都是厂商提供的一些测试数据，特别是对于随机读写的性能相比内存还是差了很多。<br>  <img src="https://static001.geekbang.org/resource/image/f3/b1/f3bcc6974bf879f35a842ecd8ee086b1.png" alt=""></li>
</ul>
<h4 id="两个疑问"><a href="#两个疑问" class="headerlink" title="两个疑问"></a>两个疑问</h4><ul>
<li><strong>疑问一：文件为什么会损坏？</strong><ul>
<li><strong>应用程序。</strong> 大部分的 I/O 方法都不是原子操作，文件的跨进程或者多线程写入、使用一个已经关闭的文件描述符 fd 来操作文件，它们都有可能导致数据被覆盖或者删除。<ul>
<li>大部分的文件损坏都是因为应用程序代码设计考虑不当导致的，并不是文件系统或者磁盘的问题。</li>
</ul>
</li>
<li><strong>文件系统。</strong> 虽说内核崩溃或者系统突然断电都有可能导致文件系统损坏，不过文件系统也做了很多的保护措施。例如 system 分区保证只读不可写，增加异常检查和恢复机制，ext4 的 fsck、f2fs 的 fsck.f2fs 和 checkpoint 机制等。<ul>
<li>在文件系统这一层，更多是因为断电而导致的写入丢失。为了提升 I/O 性能，文件系统把数据写入到 Page Cache 中，然后等待合适的时机才会真正的写入磁盘。</li>
</ul>
</li>
<li><strong>磁盘。</strong> 手机上使用的闪存是电子式的存储设备，所以在资料传输过程可能会发生电子遗失等现象导致数据错误。不过闪存也会使用 ECC、多级编码等多种方式增加数据的可靠性。<ul>
<li>一般来说出现这种情况的可能性也比较小。</li>
</ul>
</li>
<li><strong>闪存寿命也可能会导致数据错误</strong>，由于闪存的内部结构和特征，导致它写过的地址必须擦除才能再次写入，而每个块擦除又有次数限制，次数限制是根据采用的存储颗粒，从十万次到几千都有（SLC&gt;MLC&gt;TLC）。</li>
</ul>
</li>
<li><strong>疑问二：I/O 有时候为什么会突然很慢？</strong><ul>
<li><strong>内存不足。</strong> 当手机内存不足的时候，系统会回收 Page Cache 和 Buffer Cache 的内存，大部分的写操作会直接落盘，导致性能低下。</li>
<li><strong>写入放大。</strong> 上面我说到闪存重复写入需要先进行擦除操作，但这个擦除操作的基本单元是 block 块，一个 page 页的写入操作将会引起整个块数据的迁移，这就是典型的写入放大现象。低端机或者使用比较久的设备，由于磁盘碎片多、剩余空间少，非常容易出现写入放大的现象。具体来说：<ul>
<li>闪存读操作最快，在 20us 左右。</li>
<li>写操作慢于读操作，在 200us 左右。</li>
<li>擦除操作非常耗时，在 1ms 左右的数量级。当出现写入放大时，因为涉及移动数据，这个时间会更长。</li>
</ul>
</li>
<li><strong>由于低端机的 CPU 和闪存的性能相对也较差，在高负载的情况下容易出现瓶颈。</strong> 例如 eMMC 闪存不支持读写并发，当出现写入放大现象时，读操作也会受影响。</li>
</ul>
</li>
</ul>
<blockquote>
<p>系统为了缓解磁盘碎片问题，可以引入 fstrim/TRIM 机制，在锁屏、充电等一些时机会触发磁盘碎片整理。</p>
</blockquote>
<h3 id="I-O-的性能评估"><a href="#I-O-的性能评估" class="headerlink" title="I/O 的性能评估"></a>I/O 的性能评估</h3><h4 id="I-O-性能指标"><a href="#I-O-性能指标" class="headerlink" title="I/O 性能指标"></a>I/O 性能指标</h4><ul>
<li><strong>吞吐量。</strong> “连续读取不超过 550MB/s，连续写入不超过 520MB/s”，就指的是 I/O 吞吐量。</li>
<li><strong>IOPS。</strong> 它指的是每秒可以读写的次数。对于随机读写频繁的应用，例如大量的小文件存储，IOPS 是关键的衡量指标。</li>
</ul>
<h4 id="I-O-测量"><a href="#I-O-测量" class="headerlink" title="I/O 测量"></a>I/O 测量</h4><p>整个 I/O 的流程涉及的链路非常长。我们在应用程序中通过打点，发现一个文件读取需要 300ms。但是下面每一层可能都有自己的策略和调度算法，因此很难真正的得到每一层的耗时。</p>
<p><strong>Facebook 和支付宝采用编译单独 ROM 的方法来评估 I/O 性能。这是一个比较复杂但是有效的做法。</strong></p>
<p>如果不采用定制源码的方式，还有哪些方法可以用来测量 I/O 的性能呢？</p>
<ul>
<li><strong>使用 proc。</strong><ul>
<li>一个对 I/O 性能影响比较大的因素是负载，I/O 性能会随着负载的增加而降低，我们可以通过 I/O 的等待时间和次数来衡量。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proc&#x2F;self&#x2F;schedstat:</span><br><span class="line">    se.statistics.iowait_count：IO 等待的次数</span><br><span class="line">    se.statistics.iowait_sum：  IO 等待的时间</span><br></pre></td></tr></table></figure></li>
<li>如果是 root 的机器，我们可以开启内核的 I/O 监控，将所有 block 读写 dump 到日志文件中，这样可以通过 dmesg 命令来查看。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;block_dump</span><br><span class="line">dmesg -c grep pid</span><br><span class="line"></span><br><span class="line">.sample.io.test(7540): READ block 29262592 on dm-1 (256 sectors)</span><br><span class="line">.sample.io.test(7540): READ block 29262848 on dm-1 (256 sectors)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>使用 strace。</strong><ul>
<li>我们可以通过 strace 来跟踪 I/O 相关的系统调用次数和耗时。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strace -ttT -f -p [pid]</span><br><span class="line"></span><br><span class="line">read(53, &quot;*****************&quot;\.\.\., 1024) &#x3D; 1024       &lt;0.000447&gt;</span><br><span class="line">read(53, &quot;*****************&quot;\.\.\., 1024) &#x3D; 1024       &lt;0.000084&gt;</span><br><span class="line">read(53, &quot;*****************&quot;\.\.\., 1024) &#x3D; 1024       &lt;0.000059&gt;</span><br></pre></td></tr></table></figure>
  通过上面的日志，你可以看到应用程序在读取文件操作符为 53 的文件，每次读取 1024 个字节。第一次读取花了 447us，后面两次都使用了 100us 不到。文件系统每次读取以 block 为单位，而 block 的大小一般是 4KB，后面两次的读取是从页缓存得到。</li>
<li>我们也可以通过 strace 统计一段时间内所有系统调用的耗时概况。不过 strace 本身也会消耗不少资源，对执行时间也会产生影响。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strace -c -f -p [pid]</span><br><span class="line"></span><br><span class="line">% time     seconds  usecs&#x2F;call     calls    errors  syscall</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"> 97.56    0.041002          21      1987             read</span><br><span class="line">  1.44    0.000605          55        11             write</span><br></pre></td></tr></table></figure>
  从上面的信息你可以看到，读占了 97.56% 的时间，一共调用了 1987 次，耗时 0.04s，平均每次系统调用 21us。<strong>同样的道理，我们也可以计算应用程序某个任务 I/O 耗时的百分比。</strong></li>
</ul>
</li>
<li><strong>使用 vmstat。</strong><ul>
<li>其中 Memory 中的 buff 和 cache，I/O 中的 bi 和 bo，System 中的 cs，以及 CPU 中的 sy 和 wa，这些字段的数值都与 I/O 行为有关。<br>  <img src="https://static001.geekbang.org/resource/image/5f/a2/5fcc14c666f9c5c6d0cfb803634b2ba2.png" alt=""></li>
<li>我们可以配合dd 命令来配合测试，观察 vmstat 的输出数据变化。<strong>不过需要注意的是 Android 里面的 dd 命令似乎并不支持 conv 和 flag 参数。</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 清除 Buffer 和 Cache 内存缓存</span><br><span class="line">echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br><span class="line">&#x2F;&#x2F; 每隔 1 秒输出 1 组 vmstat 数据</span><br><span class="line">vmstat 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试写入速度，写入文件 &#x2F;data&#x2F;data&#x2F;test，buffer 大小为 4K，次数为 1000 次</span><br><span class="line">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;data&#x2F;data&#x2F;test bs&#x3D;4k count&#x3D;1000</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<h1 id="10-I-O优化（中）：不同I-O方式的使用场景是什么？"><a href="#10-I-O优化（中）：不同I-O方式的使用场景是什么？" class="headerlink" title="10 | I/O优化（中）：不同I/O方式的使用场景是什么？"></a>10 | I/O优化（中）：不同I/O方式的使用场景是什么？</h1><h3 id="I-O-的三种方式"><a href="#I-O-的三种方式" class="headerlink" title="I/O 的三种方式"></a>I/O 的三种方式</h3><p><img src="https://static001.geekbang.org/resource/image/3e/38/3e295519291c337bb394fb5fdbd7d538.png" alt=""></p>
<h4 id="标准-I-O"><a href="#标准-I-O" class="headerlink" title="标准 I/O"></a>标准 I/O</h4><p>我们应用程序平时用到 read/write 操作都属于标准 I/O，也就是缓存 I/O（Buffered I/O）。它的关键特性有：</p>
<ul>
<li><strong>对于读操作来说</strong>，当应用程序读取某块数据的时候，如果这块数据已经存放在页缓存中，那么这块数据就可以立即返回给应用程序，而不需要经过实际的物理读盘操作。</li>
<li><strong>对于写操作来说</strong>，应用程序也会将数据先写到页缓存中去，数据是否被立即写到磁盘上去取决于应用程序所采用写操作的机制。默认系统采用的是延迟写机制，应用程序只需要将数据写到页缓存中去就可以了，完全不需要等数据全部被写回到磁盘，系统会负责定期地将放在页缓存中的数据刷到磁盘上。</li>
<li><strong>缓存 I/O 可以很大程度减少真正读写磁盘的次数，从而提升性能。</strong> Page Cache 中被修改的内存称为“脏页”，内核通过 flush 线程定期将数据写入磁盘。具体写入的条件我们可以通过 /proc/sys/vm 文件或者 sysctl -a | grep vm 命令得到。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; flush 每隔 5 秒执行一次</span><br><span class="line">vm.dirty_writeback_centisecs &#x3D; 500  </span><br><span class="line">&#x2F;&#x2F; 内存中驻留 30 秒以上的脏数据将由 flush 在下一次执行时写入磁盘</span><br><span class="line">vm.dirty_expire_centisecs &#x3D; 3000 </span><br><span class="line">&#x2F;&#x2F; 指示若脏页占总物理内存 10％以上，则触发 flush 把脏数据写回磁盘</span><br><span class="line">vm.dirty_background_ratio &#x3D; 10</span><br><span class="line">&#x2F;&#x2F; 系统所能拥有的最大脏页缓存的总大小</span><br><span class="line">vm.dirty_ratio &#x3D; 20</span><br></pre></td></tr></table></figure></li>
<li><strong>在实际应用中，如果某些数据我们觉得非常重要，是完全不允许有丢失风险的，这个时候我们应该采用同步写机制。</strong> 在应用程序中使用 sync、fsync、msync 等系统调用时，内核都会立刻将相应的数据写回到磁盘。<ul>
<li>以 read() 操作为例，它会导致数据先从磁盘拷贝到 Page Cache 中，然后再从 Page Cache 拷贝到应用程序的用户空间，这样就会多一次内存拷贝。系统这样设计主要是因为内存相对磁盘是高速设备，即使多拷贝 100 次，内存也比真正读一次硬盘要快。<br>  <img src="https://static001.geekbang.org/resource/image/43/bd/431742f4ad3aefcc90334c905a729abd.png" alt=""></li>
</ul>
</li>
</ul>
<h4 id="直接-I-O"><a href="#直接-I-O" class="headerlink" title="直接 I/O"></a>直接 I/O</h4><p>很多数据库自己已经做了数据和索引的缓存管理，对页缓存的依赖反而没那么强烈。它们希望可以绕开页缓存机制，这样可以减少一次数据拷贝，这些数据也不会污染页缓存。</p>
<p><img src="https://static001.geekbang.org/resource/image/d7/e0/d7a24f0fe50d56df0b4f315b12d065e0.png" alt=""></p>
<ul>
<li>直接 I/O 访问文件方式减少了一次数据拷贝和一些系统调用的耗时，很大程度降低了 CPU 的使用率以及内存的占用。</li>
<li>直接 I/O 有时候也会对性能产生负面影响。<ul>
<li><strong>对于读操作来说</strong>，读数据操作会造成磁盘的同步读，导致进程需要较长的时间才能执行完。</li>
<li><strong>对于写操作来说</strong>，使用直接 I/O 也需要同步执行，也会导致应用程序等待。</li>
</ul>
</li>
<li>Android 并没有提供 Java 的 DirectByteBuffer，直接 I/O 需要在 open() 文件的时候需要指定 O_DIRECT 参数。</li>
</ul>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>它是通过把文件映射到进程的地址空间，<strong>而网上很多文章都说 mmap 完全绕开了页缓存机制，其实这并不正确。</strong> 我们最终映射的物理内存依然在页缓存中。</p>
<p><img src="https://static001.geekbang.org/resource/image/11/3e/116ada829f5017f3d40bf2f78d4f4c3e.png" alt=""></p>
<ul>
<li>优点<ul>
<li><strong>减少系统调用。</strong> 我们只需要一次 mmap() 系统调用，后续所有的调用像操作内存一样，而不会出现大量的 read/write 系统调用。</li>
<li><strong>减少数据拷贝。</strong> 普通的 read() 调用，数据需要经过两次拷贝；而 mmap 只需要从磁盘拷贝一次就可以了，并且由于做过内存映射，也不需要再拷贝回用户空间。</li>
<li><strong>可靠性高。</strong> mmap 把数据写入页缓存后，跟缓存 I/O 的延迟写机制一样，可以依靠内核线程定期写回磁盘。但是需要提的是，mmap 在内核崩溃、突然断电的情况下也一样有可能引起内容丢失，当然我们也可以使用 msync 来强制同步写。</li>
</ul>
</li>
<li>缺点<ul>
<li><strong>虚拟内存增大。</strong> mmap 会导致虚拟内存增大，我们的 APK、Dex、so 都是通过 mmap 读取。而目前大部分的应用还没支持 64 位，除去内核使用的地址空间，一般我们可以使用的虚拟内存空间只有 3GB 左右。如果 mmap 一个 1GB 的文件，应用很容易会出现虚拟内存不足所导致的 OOM。</li>
<li><strong>磁盘延迟。</strong> mmap 通过缺页中断向磁盘发起真正的磁盘 I/O，所以如果我们当前的问题是在于磁盘 I/O 的高延迟，那么用 mmap() 消除小小的系统调用开销是杯水车薪的。启动优化中讲到的类重排技术，就是将 Dex 中的类按照启动顺序重新排列，主要为了减少缺页中断造成的磁盘 I/O 延迟。</li>
</ul>
</li>
<li>在 Android 中可以将文件通过 MemoryFile 或者 MappedByteBuffer 映射到内存，然后进行读写，使用这种方式对于小文件和频繁读写操作的文件还是有一定优势的。<ul>
<li>mmap 比较适合于对同一块区域频繁读写的情况，推荐也使用线程来操作。用户日志、数据上报都满足这种场景。</li>
<li>需要跨进程同步的时候，mmap 也是一个不错的选择。Android 跨进程通信有自己独有的 Binder 机制，它内部也是使用 mmap 实现。</li>
</ul>
</li>
</ul>
<h3 id="多线程阻塞-I-O-和-NIO"><a href="#多线程阻塞-I-O-和-NIO" class="headerlink" title="多线程阻塞 I/O 和 NIO"></a>多线程阻塞 I/O 和 NIO</h3><p>由于写入放大的现象，特别是在低端机中，有时候 I/O 操作可能会非常慢。</p>
<p>所以 I/O 操作应该尽量放到线程中，不过很多同学可能都有这样一个疑问：如果同时读 10 个文件，我们应该用单线程还是 10 个线程并发读？</p>
<h4 id="多线程阻塞-I-O"><a href="#多线程阻塞-I-O" class="headerlink" title="多线程阻塞 I/O"></a>多线程阻塞 I/O</h4><p>多线程在 I/O 操作上收益并没有那么大，因为 CPU 的性能相比磁盘来说就是火箭，I/O 操作主要瓶颈在于磁盘带宽，几十条线程并不会有几十倍的收益。<strong>总的来说文件读写受到 I/O 性能瓶颈的影响，在到达一定速度后整体性能就会受到明显的影响，过多的线程反而会导致应用整体性能的明显下降。</strong></p>
<p>同步 I/O 的工作模式如下图所示：<br><img src="https://static001.geekbang.org/resource/image/3f/43/3f322506a458d60145cee27f55673743.png" alt=""></p>
<p>以下面两种情况举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">案例一:</span><br><span class="line">CPU: 0.3% user, 3.1% kernel, 60.2% iowait, 36% idle\.\.\.</span><br><span class="line">案例二：</span><br><span class="line">CPU: 60.3% user, 20.1% kernel, 14.2% iowait, 4.6% idle\.\.\.</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>案例一：</strong> 当系统空闲（36% idle）时，如果没有其他线程需要调度，这个时候才会出现 I/O 等待（60.2% iowait）。</li>
<li><strong>案例二：</strong> 如果我们的系统繁忙起来，这个时候 CPU 不会“无所事事”，它会去看有没有其他线程需要调度，这个时候 I/O 等待会降低（14.2% iowait）。但是太多的线程阻塞会导致线程切换频繁，增大系统上下文切换的开销。</li>
</ul>
<p><strong>简单来说，iowait 高，I/O 一定有问题。但 iowait 低，I/O 不一定没有问题。这个时候我们还要看 CPU 的 idle 比例。</strong></p>
<p><strong>在实际开发工作中，大部分时候都是读一些比较小的文件，使用单独的 I/O 线程还是专门新开一个线程，其实差别不大。</strong></p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO 过程可以参考下面的图。<br><img src="https://static001.geekbang.org/resource/image/22/f9/22141f888cefc43219b0c3df3ab8d4f9.png" alt=""></p>
<ul>
<li><strong>优点:</strong> 非阻塞的 NIO 将 I/O 以事件的方式通知，的确可以减少线程切换的开销。<ul>
<li>Chrome 网络库是一个使用 NIO 提升性能很好的例子，特别是在系统非常繁忙的时候。</li>
</ul>
</li>
<li><strong>缺点:</strong> 应用程序的实现会变得更复杂，有的时候异步改造并不容易。</li>
</ul>
<p><strong>NIO 整体性能跟非 NIO 差别并不大，使用 NIO 的最大作用不是减少读取文件的耗时，而是最大化提升应用整体的 CPU 利用率。</strong> 在 CPU 繁忙的时候，我们可以将线程等待磁盘 I/O 的时间来做部分 CPU 操作。</p>
<h3 id="小文件系统"><a href="#小文件系统" class="headerlink" title="小文件系统"></a>小文件系统</h3><p>读取一个文件的耗时可以拆分成下面两个部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件读取的时间 &#x3D; 找到文件的 inode 的时间 + 根据 inode 读取文件数据的时间</span><br></pre></td></tr></table></figure>

<p>如果我们需要频繁读写几万个小文件，查找 inode 的时间会变得非常可观。这个时间跟文件系统的实现有关。</p>
<ul>
<li>对于 FAT32 系统来说，FAT32 系统是历史久远的产物，在一些低端机的外置 SD 卡会使用这个系统。当目录文件数比较多的时候，需要线性去查找，一个 exist() 都非常容易出现 ANR。</li>
<li>对于 ext4 系统来说，ext4 系统使用目录 Hash 索引的方式查找，目录查找时间会大大缩短。但是如果需要频繁操作大量的小文件，查找和打开文件的耗时也不能忽视。</li>
</ul>
<p>大量的小文件合并为大文件后，我们还可以将能连续访问的小文件合并存储。</p>
<ul>
<li>原本小文件间的随机访问变为了顺序访问，可以大大提高性能。</li>
<li>合并存储能够有效减少小文件存储时所产生的磁盘碎片问题，提高磁盘的利用率。</li>
<li><strong>案例</strong><ul>
<li>Google 的 GFS</li>
<li>淘宝开源的TFS</li>
<li>Facebook 的 Haystack</li>
<li>微信的 SFS，主要用在朋友圈图片的管理，用于解决当时外置 SD 卡使用 FAT32 的性能问题。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="11-I-O优化（下）：如何监控线上I-O操作？"><a href="#11-I-O优化（下）：如何监控线上I-O操作？" class="headerlink" title="11 | I/O优化（下）：如何监控线上I/O操作？"></a>11 | I/O优化（下）：如何监控线上I/O操作？</h1><h3 id="I-O-跟踪"><a href="#I-O-跟踪" class="headerlink" title="I/O 跟踪"></a>I/O 跟踪</h3><h4 id="Java-Hook"><a href="#Java-Hook" class="headerlink" title="Java Hook"></a>Java Hook</h4><p>以 Android 6.0 的源码为例，FileInputStream 的整个调用流程如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java : FileInputStream </span><br><span class="line">-&gt; IoBridge.open </span><br><span class="line">-&gt; Libcore.os.open </span><br><span class="line">-&gt; BlockGuardOs.open </span><br><span class="line">-&gt; Posix.open</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何可以快速找到合适的 Hook 点呢？一方面需要靠经验，但是耐心查看和分析源码是必不可少的工作。</p>
</blockquote>
<p>在Libcore.java中可以找到一个挺不错的 Hook 点，那就是BlockGuardOs这一个静态变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Os os &#x3D; new BlockGuardOs(new Posix());</span><br><span class="line">&#x2F;&#x2F; 反射获得静态变量</span><br><span class="line">Class&lt;?&gt; clibcore &#x3D; Class.forName(&quot;libcore.io.Libcore&quot;);</span><br><span class="line">Field fos &#x3D; clibcore.getDeclaredField(&quot;os&quot;);</span><br></pre></td></tr></table></figure>
<p>我们可以通过动态代理的方式，在所有 I/O 相关方法前后加入插桩代码，统计 I/O 操作相关的信息。事实上，BlockGuardOs 里面还有一些 Socket 相关的方法，我们也可以用来统计网络相关的请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 动态代理对象</span><br><span class="line">Proxy.newProxyInstance(cPosix.getClassLoader(), getAllInterfaces(cPosix), this);</span><br><span class="line"></span><br><span class="line">beforeInvoke(method, args, throwable);</span><br><span class="line">result &#x3D; method.invoke(mPosixOs, args);</span><br><span class="line">afterInvoke(method, args, result);</span><br></pre></td></tr></table></figure>

<p>这个方法有几个缺点。</p>
<ul>
<li><strong>性能极差。</strong> I/O 操作调用非常频繁，因为使用动态代理和 Java 的大量字符串操作，导致性能比较差，无法达到线上使用的标准。</li>
<li><strong>无法监控 Native 代码。</strong> 例如微信中有大量的 I/O 操作是在 Native 代码中，使用 Java Hook 方案无法监控到。</li>
<li><strong>兼容性差。</strong> Java Hook 需要每个 Android 版本去兼容，特别是 Android P 增加对非公开 API 限制。</li>
</ul>
<h4 id="Native-Hook"><a href="#Native-Hook" class="headerlink" title="Native Hook"></a>Native Hook</h4><p>从 libc.so 中的这几个函数中选定 Hook 的目标函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line">ssize_t read(int fd, void *buf, size_t size);</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t size); write_cuk</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure>

<p>有两种 hook 方案可以选择。</p>
<ul>
<li><strong>Profilo 使用的是 PLT Hook 方案，它的性能更好一些。</strong> Profilo 中atrace.cpp的做法，它直接遍历所有已经加载的 library，一并替换。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void hookLoadedLibs() &#123;</span><br><span class="line">    auto&amp; functionHooks &#x3D; getFunctionHooks();</span><br><span class="line">    auto&amp; seenLibs &#x3D; getSeenLibs();</span><br><span class="line">    facebook::profilo::hooks::hookLoadedLibs(functionHooks, seenLibs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  不同版本的 Android 系统实现有所不同，在 Android 7.0 之后，我们还需要替换下面这三个方法。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open64</span><br><span class="line">__read_chk</span><br><span class="line">__write_chk</span><br></pre></td></tr></table></figure></li>
<li><strong>GOT Hook 的兼容性会更好一些。</strong> 使用 GOT Hook 需要选择一些有调用上面几个方法的 library。微信 Matrix 中选择的是 libjavacore.so`、libopenjdkjvm.so、libopenjdkjvm.so，可以覆盖到所有的 Java 层的 I/O 调用，具体可以参考 <a href="https://github.com/Tencent/matrix/blob/master/matrix/matrix-android/matrix-io-canary/src/main/cpp/io_canary_jni.cc#L161" target="_blank" rel="noopener">io_canary_jni.cc</a>。</li>
</ul>
<h4 id="监控内容"><a href="#监控内容" class="headerlink" title="监控内容"></a>监控内容</h4><p>通过上面 Hook 的四个接口，我们可以很容易的采集到这些信息。<br><img src="https://static001.geekbang.org/resource/image/ba/3c/ba36f8e259427bde06bc44861905c63c.png" alt=""></p>
<p><strong>举例:</strong> 下面是一次 I/O 操作的基本信息，在主线程对一个大小为 600KB 的“test.db”文件。<br><img src="https://static001.geekbang.org/resource/image/07/ae/0732644e3734490825c896fa559bcaae.png" alt=""></p>
<p>使用了 4KB 的 Buffer，连续读取 150 次，一次性把整个文件读完，整体的耗时是 10ms。因为连读读写时间和打开文件的总时间相同，我们可以判断出这次 read() 操作是一气呵成的，中间没有间断。<br><img src="https://static001.geekbang.org/resource/image/aa/fb/aab6899b0b7a91f466e187333337dcfb.png" alt=""></p>
<p>对比是否使用 Native Hook 的耗时数据。可以看到采用 Native Hook 的监控方法性能损耗基本可以忽略，这套方案可以用于线上。<br><img src="https://static001.geekbang.org/resource/image/f0/5f/f0394337bee26e8bf105cfd1eda37a5f.png" alt=""></p>
<h3 id="线上监控-1"><a href="#线上监控-1" class="headerlink" title="线上监控"></a>线上监控</h3><p>对于 I/O 的线上监控，我们需要进一步抽象出规则，明确哪些情况可以定义为不良情况，需要上报到后台，进而推动开发去解决。<br><img src="https://static001.geekbang.org/resource/image/9c/3a/9c408d0ec409771c2a036f0208cadf3a.png" alt=""></p>
<h4 id="主线程-I-O"><a href="#主线程-I-O" class="headerlink" title="主线程 I/O"></a>主线程 I/O</h4><ul>
<li>只上传 “连续读写时间超过 100 毫秒” 的问题。之所以使用连续读写时间，是因为发现有不少案例是打开了文件句柄，但不是一次读写完的。</li>
<li>在上报问题到后台时，为了能更好地定位解决问题，我通常还会把 CPU 使用率、其他线程的信息以及内存信息一并上报，辅助分析问题。</li>
</ul>
<h4 id="读写-Buffer-过小"><a href="#读写-Buffer-过小" class="headerlink" title="读写 Buffer 过小"></a>读写 Buffer 过小</h4><p>如果我们的 Buffer 太小，会导致多次无用的系统调用和内存拷贝，导致 read/write 的次数增多，从而影响了性能。</p>
<p>我们可以跟据文件保存所挂载的目录的 block size 来确认 Buffer 大小，数据库中的pagesize就是这样确定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StatFs(&quot;&#x2F;data&quot;).getBlockSize()</span><br></pre></td></tr></table></figure>

<p>所以我们最终选择的判断条件为：</p>
<ul>
<li>buffer size 小于 block size，这里一般为 4KB。</li>
<li>read/write 的次数超过一定的阈值，例如 5 次，这主要是为了减少上报量。</li>
</ul>
<p><strong>如果使用 BufferInputStream 或者 ByteArrayOutputStream 后整体性能会有非常明显的提升。</strong><br><img src="https://static001.geekbang.org/resource/image/81/f5/81fa5cac7b7c91e0687c11fb83e35df5.png" alt=""></p>
<p><strong>准确评估磁盘真实的读写次数是比较难的。</strong> 磁盘内部也会有很多的策略，例如预读。它可能发生超过你真正读的内容，预读在有大量顺序读取磁盘的时候，readahead 可以大幅提高性能。但是大量读取碎片小文件的时候，可能又会造成浪费。</p>
<ul>
<li>可以通过下面的这个文件查看预读的大小，一般是 128KB。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sys&#x2F;block&#x2F;[disk]&#x2F;queue&#x2F;read_ahead_kb</span><br></pre></td></tr></table></figure></li>
<li>可以利用 /proc/sys/vm/block_dump 或者/proc/diskstats的信息统计真正的磁盘读写次数。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;proc&#x2F;diskstats</span><br><span class="line">块设备名字|读请求次数|读请求扇区数|读请求耗时总和\.\.\.\.</span><br><span class="line">dm-0 23525 0 1901752 45366 0 0 0 0 0 33160 57393</span><br><span class="line">dm-1 212077 0 6618604 430813 1123292 0 55006889 3373820 0 921023 3805823</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="重复读"><a href="#重复读" class="headerlink" title="重复读"></a>重复读</h4><p>为了减少上报量，可以增加以下几个条件：</p>
<ul>
<li>重复读取次数超过 3 次，并且读取的内容相同。</li>
<li>读取期间文件内容没有被更新，也就是没有发生过 write。</li>
</ul>
<p>针对重复读造成的性能问题，加一层内存 cache 是最直接有效的办法，比较典型的场景是配置文件等一些数据模块的加载，如果没有内存 cache，那么性能影响就比较大了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String readConfig() &#123;</span><br><span class="line">  if (Cache !&#x3D; null) &#123;</span><br><span class="line">     return cache; </span><br><span class="line">  &#125;</span><br><span class="line">  cache &#x3D; read(&quot;configFile&quot;);</span><br><span class="line">  return cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="资源泄漏"><a href="#资源泄漏" class="headerlink" title="资源泄漏"></a>资源泄漏</h4><p>可以利用了 Android 框架中的 StrictMode 来监控资源泄露，StrictMode 利用 CloseGuard.java 类在很多系统代码已经预置了埋点。</p>
<p>接下来还是查看源码寻找可以利用的 Hook 点。CloseGuard 中的 REPORTER 对象就是一个可以利用的点。具体步骤如下：</p>
<ul>
<li>利用反射，把 CloseGuard 中的 ENABLED 值设为 true。</li>
<li>利用动态代理，把 REPORTER 替换成我们定义的 proxy。</li>
</ul>
<p>虽然在 Android 源码中，StrictMode 已经预埋了很多的资源埋点。不过肯定还有埋点是没有的，比如 MediaPlayer、程序内部的一些资源模块。所以在程序中也写了一个 MyCloseGuard 类，对希望增加监控的资源，可以手动增加埋点代码。</p>
<h3 id="I-O-与启动优化"><a href="#I-O-与启动优化" class="headerlink" title="I/O 与启动优化"></a>I/O 与启动优化</h3><p>通过 I/O 跟踪，可以拿到整个启动过程所有 I/O 操作的详细信息列表。</p>
<p>我们需要更加的苛刻地检查每一处 I/O 调用。是否每一处 I/O 调用都是必不可少的，特别是 write()。主线程 I/O、读写 Buffer、重复读以及资源泄漏是首先需要解决的，特别是重复读，比如 cpuinfo、手机内存这些信息都应该缓存起来。</p>
<p>对于必不可少的 I/O 操作，我们需要思考是否有其他方式做进一步的优化。</p>
<ul>
<li><strong>对大文件使用 mmap 或者 NIO 方式。</strong> MappedByteBuffer 就是 Java NIO 中的 mmap 封装，正如上一期所说，对于大文件的频繁读写会有比较大的优化。</li>
<li><strong>安装包不压缩。</strong> 对启动过程需要的文件，我们可以指定在安装包中不压缩，这样也会加快启动速度，但带来的影响是安装包体积增大。事实上 Google Play 非常希望我们不要去压缩 library、resource、resource.arsc 这些文件，这样对启动的内存和速度都会有很大帮助。而且不压缩文件带来只是安装包体积的增大，对于用户来说，Download size 并没有增大。</li>
<li><strong>Buffer 复用。</strong> 我们可以利用 Okio 开源库，它内部的 ByteString 和 Buffer 通过重用等技巧，很大程度上减少 CPU 和内存的消耗。</li>
<li><strong>存储结构和算法的优化。</strong> 是否可以通过算法或者数据结构的优化，让我们可以尽量的少 I/O 甚至完全没有 I/O。比如一些配置文件从启动完全解析，改成读取时才解析对应的项；替换掉 XML、JSON 这些格式比较冗余、性能比较较差的数据结构。</li>
</ul>
<hr>
<h1 id="12-存储优化（上）：常见的数据存储方法有哪些？"><a href="#12-存储优化（上）：常见的数据存储方法有哪些？" class="headerlink" title="12 | 存储优化（上）：常见的数据存储方法有哪些？"></a>12 | 存储优化（上）：常见的数据存储方法有哪些？</h1><h3 id="Android-的存储基础"><a href="#Android-的存储基础" class="headerlink" title="Android 的存储基础"></a>Android 的存储基础</h3><h4 id="Android-分区"><a href="#Android-分区" class="headerlink" title="Android 分区"></a>Android 分区</h4><!-- flag of hidden posts -->
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/about/">关于</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#01-崩溃优化（上）：关于“崩溃”那些事儿"><span class="toc-number">1.</span> <span class="toc-text">01 | 崩溃优化（上）：关于“崩溃”那些事儿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-的两种崩溃"><span class="toc-number">1.0.1.</span> <span class="toc-text">Android 的两种崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Native-崩溃"><span class="toc-number">1.0.2.</span> <span class="toc-text">Native 崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何客观地衡量崩溃"><span class="toc-number">1.0.3.</span> <span class="toc-text">如何客观地衡量崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何客观地衡量稳定性"><span class="toc-number">1.0.4.</span> <span class="toc-text">如何客观地衡量稳定性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02-崩溃优化（下）：应用崩溃了，你应该如何去分析？"><span class="toc-number">2.</span> <span class="toc-text">02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#崩溃现场"><span class="toc-number">2.0.1.</span> <span class="toc-text">崩溃现场</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#崩溃分析"><span class="toc-number">2.0.2.</span> <span class="toc-text">崩溃分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03-内存优化（上）：4GB内存时代，再谈内存优化"><span class="toc-number">3.</span> <span class="toc-text">03 | 内存优化（上）：4GB内存时代，再谈内存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存问题"><span class="toc-number">3.0.1.</span> <span class="toc-text">内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#两个问题"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">两个问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个误区"><span class="toc-number">3.0.1.2.</span> <span class="toc-text">两个误区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-Bitmap-内存分配的变化"><span class="toc-number">3.0.1.3.</span> <span class="toc-text">Android Bitmap 内存分配的变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何将图片放到-Native-内存"><span class="toc-number">3.0.1.4.</span> <span class="toc-text">如何将图片放到 Native 内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测量方法"><span class="toc-number">3.0.2.</span> <span class="toc-text">测量方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-内存优化（下）：内存优化这件事，应该从哪里着手？"><span class="toc-number">4.</span> <span class="toc-text">04 | 内存优化（下）：内存优化这件事，应该从哪里着手？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存优化探讨"><span class="toc-number">4.0.1.</span> <span class="toc-text">内存优化探讨</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存监控"><span class="toc-number">4.0.2.</span> <span class="toc-text">内存监控</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05-卡顿优化（上）：你要掌握的卡顿分析方法"><span class="toc-number">5.</span> <span class="toc-text">05 | 卡顿优化（上）：你要掌握的卡顿分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础知识"><span class="toc-number">5.0.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-时间"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">CPU 时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-性能"><span class="toc-number">5.0.1.2.</span> <span class="toc-text">CPU 性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卡顿问题分析指标"><span class="toc-number">5.0.1.3.</span> <span class="toc-text">卡顿问题分析指标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-卡顿排查工具"><span class="toc-number">5.0.2.</span> <span class="toc-text">Android 卡顿排查工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Traceview"><span class="toc-number">5.0.2.1.</span> <span class="toc-text">Traceview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nanoscope"><span class="toc-number">5.0.2.2.</span> <span class="toc-text">Nanoscope</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#systrace"><span class="toc-number">5.0.2.3.</span> <span class="toc-text">systrace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Simpleperf"><span class="toc-number">5.0.2.4.</span> <span class="toc-text">Simpleperf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工具选择"><span class="toc-number">5.0.2.5.</span> <span class="toc-text">工具选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可视化方法"><span class="toc-number">5.0.3.</span> <span class="toc-text">可视化方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06-卡顿优化（下）：如何监控应用卡顿？"><span class="toc-number">6.</span> <span class="toc-text">06 | 卡顿优化（下）：如何监控应用卡顿？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#卡顿监控"><span class="toc-number">6.0.1.</span> <span class="toc-text">卡顿监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#消息队列"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插桩"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">插桩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Profilo"><span class="toc-number">6.0.1.3.</span> <span class="toc-text">Profilo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他监控"><span class="toc-number">6.0.2.</span> <span class="toc-text">其他监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#帧率"><span class="toc-number">6.0.2.1.</span> <span class="toc-text">帧率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生命周期监控"><span class="toc-number">6.0.2.2.</span> <span class="toc-text">生命周期监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程监控"><span class="toc-number">6.0.2.3.</span> <span class="toc-text">线程监控</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">6.0.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06补充篇-卡顿优化：卡顿现场与卡顿分析"><span class="toc-number">7.</span> <span class="toc-text">06补充篇 | 卡顿优化：卡顿现场与卡顿分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#卡顿现场"><span class="toc-number">7.0.1.</span> <span class="toc-text">卡顿现场</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-实现"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">Java 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SIGQUIT-信号实现-获取-ANR-日志"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">SIGQUIT 信号实现 (获取 ANR 日志)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook-实现"><span class="toc-number">7.0.1.3.</span> <span class="toc-text">Hook 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他卡顿现场信息"><span class="toc-number">7.0.1.4.</span> <span class="toc-text">其他卡顿现场信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#卡顿分析"><span class="toc-number">7.0.2.</span> <span class="toc-text">卡顿分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#卡顿率"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">卡顿率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卡顿树"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">卡顿树</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07-启动优化（上）：从启动过程看启动速度优化"><span class="toc-number">8.</span> <span class="toc-text">07 | 启动优化（上）：从启动过程看启动速度优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动分析"><span class="toc-number">8.0.1.</span> <span class="toc-text">启动分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#启动过程分析"><span class="toc-number">8.0.1.1.</span> <span class="toc-text">启动过程分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启动问题分析"><span class="toc-number">8.0.1.2.</span> <span class="toc-text">启动问题分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动优化"><span class="toc-number">8.0.2.</span> <span class="toc-text">启动优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优化工具"><span class="toc-number">8.0.2.1.</span> <span class="toc-text">优化工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化方式"><span class="toc-number">8.0.2.2.</span> <span class="toc-text">优化方式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08-启动优化（下）：优化启动速度的进阶方法"><span class="toc-number">9.</span> <span class="toc-text">08 | 启动优化（下）：优化启动速度的进阶方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动进阶方法"><span class="toc-number">9.0.1.</span> <span class="toc-text">启动进阶方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-优化"><span class="toc-number">9.0.1.1.</span> <span class="toc-text">I&#x2F;O 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据重排"><span class="toc-number">9.0.1.2.</span> <span class="toc-text">数据重排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类的加载"><span class="toc-number">9.0.1.3.</span> <span class="toc-text">类的加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#黑科技"><span class="toc-number">9.0.1.4.</span> <span class="toc-text">黑科技</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动监控"><span class="toc-number">9.0.2.</span> <span class="toc-text">启动监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实验室监控"><span class="toc-number">9.0.2.1.</span> <span class="toc-text">实验室监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线上监控"><span class="toc-number">9.0.2.2.</span> <span class="toc-text">线上监控</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09-I-O优化（上）：开发工程师必备的I-O优化知识"><span class="toc-number">10.</span> <span class="toc-text">09 | I&#x2F;O优化（上）：开发工程师必备的I&#x2F;O优化知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-的基本知识"><span class="toc-number">10.0.1.</span> <span class="toc-text">I&#x2F;O 的基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件系统"><span class="toc-number">10.0.1.1.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#磁盘"><span class="toc-number">10.0.1.2.</span> <span class="toc-text">磁盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-I-O"><span class="toc-number">10.0.2.</span> <span class="toc-text">Android I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-闪存"><span class="toc-number">10.0.2.1.</span> <span class="toc-text">Android 闪存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个疑问"><span class="toc-number">10.0.2.2.</span> <span class="toc-text">两个疑问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-的性能评估"><span class="toc-number">10.0.3.</span> <span class="toc-text">I&#x2F;O 的性能评估</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-性能指标"><span class="toc-number">10.0.3.1.</span> <span class="toc-text">I&#x2F;O 性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-测量"><span class="toc-number">10.0.3.2.</span> <span class="toc-text">I&#x2F;O 测量</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-I-O优化（中）：不同I-O方式的使用场景是什么？"><span class="toc-number">11.</span> <span class="toc-text">10 | I&#x2F;O优化（中）：不同I&#x2F;O方式的使用场景是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-的三种方式"><span class="toc-number">11.0.1.</span> <span class="toc-text">I&#x2F;O 的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#标准-I-O"><span class="toc-number">11.0.1.1.</span> <span class="toc-text">标准 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#直接-I-O"><span class="toc-number">11.0.1.2.</span> <span class="toc-text">直接 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap"><span class="toc-number">11.0.1.3.</span> <span class="toc-text">mmap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程阻塞-I-O-和-NIO"><span class="toc-number">11.0.2.</span> <span class="toc-text">多线程阻塞 I&#x2F;O 和 NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程阻塞-I-O"><span class="toc-number">11.0.2.1.</span> <span class="toc-text">多线程阻塞 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO"><span class="toc-number">11.0.2.2.</span> <span class="toc-text">NIO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小文件系统"><span class="toc-number">11.0.3.</span> <span class="toc-text">小文件系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-I-O优化（下）：如何监控线上I-O操作？"><span class="toc-number">12.</span> <span class="toc-text">11 | I&#x2F;O优化（下）：如何监控线上I&#x2F;O操作？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-跟踪"><span class="toc-number">12.0.1.</span> <span class="toc-text">I&#x2F;O 跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-Hook"><span class="toc-number">12.0.1.1.</span> <span class="toc-text">Java Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Native-Hook"><span class="toc-number">12.0.1.2.</span> <span class="toc-text">Native Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#监控内容"><span class="toc-number">12.0.1.3.</span> <span class="toc-text">监控内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线上监控-1"><span class="toc-number">12.0.2.</span> <span class="toc-text">线上监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主线程-I-O"><span class="toc-number">12.0.2.1.</span> <span class="toc-text">主线程 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读写-Buffer-过小"><span class="toc-number">12.0.2.2.</span> <span class="toc-text">读写 Buffer 过小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重复读"><span class="toc-number">12.0.2.3.</span> <span class="toc-text">重复读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#资源泄漏"><span class="toc-number">12.0.2.4.</span> <span class="toc-text">资源泄漏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-与启动优化"><span class="toc-number">12.0.3.</span> <span class="toc-text">I&#x2F;O 与启动优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-存储优化（上）：常见的数据存储方法有哪些？"><span class="toc-number">13.</span> <span class="toc-text">12 | 存储优化（上）：常见的数据存储方法有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-的存储基础"><span class="toc-number">13.0.1.</span> <span class="toc-text">Android 的存储基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-分区"><span class="toc-number">13.0.1.1.</span> <span class="toc-text">Android 分区</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&text=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&title=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&is_video=false&description=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=极客时间 - 《Android开发高手课》笔记&body=Check out this article: http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&title=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&title=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&title=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&title=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&name=极客时间 - 《Android开发高手课》笔记&description=&lt;h1 id=&#34;01-崩溃优化（上）：关于“崩溃”那些事儿&#34;&gt;&lt;a href=&#34;#01-崩溃优化（上）：关于“崩溃”那些事儿&#34; class=&#34;headerlink&#34; title=&#34;01 | 崩溃优化（上）：关于“崩溃”那些事儿&#34;&gt;&lt;/a&gt;01 | 崩溃优化（上）：关于“崩溃”那些事儿&lt;/h1&gt;&lt;h3 id=&#34;Android-的两种崩溃&#34;&gt;&lt;a href=&#34;#Android-的两种崩溃&#34; class=&#34;headerlink&#34; title=&#34;Android 的两种崩溃&#34;&gt;&lt;/a&gt;Android 的两种崩溃&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java 崩溃:&lt;/strong&gt; 在 Java 代码中，出现了未捕获异常，导致程序异常退出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Native 崩溃:&lt;/strong&gt; 一般是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，这些都会产生相应的 signal 信号，导致程序异常退出。&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://yueban.github.io/2019/04/09/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0/&t=极客时间 - 《Android开发高手课》笔记" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2014-2020
    月半兄
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/about/">关于</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-NTW74P86FN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-NTW74P86FN');
    </script>

<!-- Baidu Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
